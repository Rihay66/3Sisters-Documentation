<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[3Sisters-Legacy-Documentation]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>3Sisters-Legacy-Documentation</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 16 Feb 2026 23:37:20 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 16 Feb 2026 23:37:13 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Window-GLFW]]></title><description><![CDATA[The Window-GLFW class is responsible for creating a OpenGL context window utilizing the GLFW library which allows for direct/indirect functionality of other components within the engine such as the <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a>. Refer to GLFW documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/" target="_self">https://www.glfw.org/docs/latest/</a> Refer to OpenGL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Header location/namespace/class name#include &lt;window/sisters_glfw_window.hpp&gt; namespace GLFW{
class Window{
...
};
} used to set the target frame time between frame, aka max frame time
the default value for time step is 16.6ms or 60 frames per second
// in order to utilize function must use inheritance
void AppWindow::func(){ // set target time step to 60 frames per second setTargetTimeStep(1.0f/60.0f); } used to set the fixed frame time between frame
the default value for fixed time step is 16.6ms or 60 frames per second
// in order to utilize function must use inheritance
void AppWindow::func(){ // set target time step to 60 frames per second setFixedTimeStep(1.0f/60.0f); } used for adding additional GLFW window hints
this function gets called by initializeWindow()
// in order to utilize function must use inheritance
void AppWindow::additionalWindowOptions(){ // add additional window options // refer to GLFW documentation // example: upon window creation, maximize the window glfwWindowHint(GLFW_MAXIMIZED, GLFW_TRUE);
} used for setting up OpenGL rendering
by default it is defined to allow for 2D rendering
// in order to utilize function must use inheritance
void AppWindow::setUpOpenGL(){ // set opengl rendering // refer to OpenGL documentation // example: set up rendering for 2D glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
} used to retrieve how long a frame took
variable is only populated by runtime(), unless overwrite of runtime() makes use of the variable
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 window.initializeWindow(800, 600); // call runtime window.runtime();
} // in order to utilize function must use inheritance
void AppWindow::func(){ // retrieve length of frame double frame_length = getFrameDuration();
} used to retrieve the current frame
variable is only populated by runtime(), unless overwrite of runtime() makes use of the variable
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 window.initializeWindow(800, 600); // call runtime window.runtime();
} // in order to utilize function must use inheritance
void AppWindow::func(){ // retrieve length of frame double frame_length = getCurrentFrame();
} used to initialize the window and it's contexts by default initializes GLFW and creates a Window with OpenGL 4.5 capabilities
sets the window handle context which can be retrieved
the last parameter, const char*, gives the window a name which is optional
during initialization it calls additionalWindowOptions() and setUpOpenGL()
overwriting is not recommended, however due note that runtime(), getDeltaTime(), setUpOpenGL() require GLFW to be initialized and have a created window handle context
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 window.initializeWindow(800, 600);
} // *Alternative*
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 with a name window.initializeWindow(800, 600, "My App");
} used to grab reference to the window handle context
returns glfwWindow* created from initializeWindow(), else returns nullptr when initializeWindow() is never called
void func(){ // grab reference to the window handle glfwWindow* handle = window.getWindowHandle(); // example: use glfw handle to get keyboard input when pressed // refer to GLFW documentation if(glfwGetKey(handle, GLFW_KEY_E) == GLFW_PRESS){ // do something... } } returns the current delta time
overwriting may need further modifications or accommodation to the update(), stepUpdate(), and render() as it may cause unintended behavior
void func(){ // obtain the deltatime float dt = window.getDeltaTime(); // example: use deltatime to have smooth vector translation player.position.x = movement * dt;
} returns the width of the window
when initializeWindow() is not called, this functions returns 0
void func(){ // obtain the width of the window unsigned int w = window.getWidth();
} returns the Height of the window
when initializeWindow() is not called, this functions returns 0
void func(){ // obtain the height of the window unsigned int w = window.getHeight();
} used to call functions that handle the loading of shaders, textures, and objects
must at least be called once
// in order to utilize function must use inheritance
void AppWindow::init(){ // example: initialize a player object player.init();
} used to update Physics, ticks systems, or other at a fixed time step
the parameter of double is the calculate fixed time step value
// in order to utilize function must use inheritance
void AppWindow::stepUpdate(double ts){ // example: make a position vector move left over time position.x += 5.0f * ts
} used to update logic, custom events, and other at the target time step
// in order to utilize function must use inheritance
void AppWindow::update(){ // example: check a list of player of which one is not alive for(auto&amp; plr: players){ if(plr.isAlive == false){ //do something... } }
} used to render things on the screen
the parameter is used for linear interpolation to render things smoothly no matter the target time step
#include &lt;engine/sprite_renderer.hpp&gt; // in order to utilize function must use inheritance
void AppWindow::render(double alpha){ // example: flush all acumulated quads SpriteRenderer::FlushQuads();
} calls Init() once, then loops through getDeltaTime(), update(), stepUpdate(), and render()
in addition it calls calls GLFW poll events, swap buffers and clears the OpenGL color buffer
if overwritten, may need to apply calculations of time step, fixed time step and accumulator yourself
void func(){ // call runtime window.runtime();
}
]]></description><link>engine/window/src/window-glfw.html</link><guid isPermaLink="false">Engine/Window/src/Window-GLFW.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Window-SDL]]></title><description><![CDATA[The Window-SDL class is responsible for creating a OpenGL context window utilizing the SDL library which allows for direct/indirect functionality of other components within the engine such as the <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a>. Refer to SDL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/FrontPage" target="_self">https://wiki.libsdl.org/SDL3/FrontPage</a>
Refer to OpenGL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Header Location/namespace/class name#include &lt;window/sisters_sdl_window.hpp&gt; namespace SDL{
class Window{
...
};
} used to set the target frame time between frame, aka max frame time
the default value for time step is 16.6ms or 60 frames per second
// in order to utilize function must use inheritance
void AppWindow::func(){ // set target time step to 60 frames per second setTargetTimeStep(1.0f/60.0f); } used to set the fixed frame time between frame
the default value for fixed time step is 16.6ms or 60 frames per second
// in order to utilize function must use inheritance
void AppWindow::func(){ // set target time step to 60 frames per second setFixedTimeStep(1.0f/60.0f); } used to set the mouse wheel stop speed
either allow to be more floating or exact when there's mouse wheel input
Default: value for mouse wheel stop speed is 0.25
// in order to utilize function must use inheritance
void AppWindow::func(){ // change how fast the mouse wheel input setMouseWheelStopSpeed(0.25f);
} used to set the mouse wheel stop deadzone
when to start detecting mouse wheel input
the default value for mouse wheel stop deadzone is 0.5
// in order to utilize function must use inheritance
void AppWindow::func(){ // change when to stop detecting input setMouseWheelStopDeadzone(0.5f);
} used for adding additional SDL window hints
this function gets called by initializeWindow()
// in order to utilize function must use inheritance
void AppWindow::additionalWindowOptions(){ // add additional window options // refer to SDL documentation // example: upon window creation, fullscreen the window // set window to be fullscreen SDL_SetWindowFullscreen(getWindowHandle(), true);
} used for setting up OpenGL rendering
by default it is defined to allow for 2D rendering
// in order to utilize function must use inheritance
void AppWindow::setUpOpenGL(){ // set opengl rendering // refer to OpenGL documentation // example: set up rendering for 2D glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
} used for adding additional functionality when polling events
// in order to utilize function must use inheritance
void AppWindow::additionalEventHandling(SDL_Event* event){ // used to handle any additional SDL events // Example: polling a cliboard event switch(event.type){ case SDL_EVENT_CLIPBOARD_UPDATE: // Do something... break; default: break; }
} used to retrieve how long a frame took
variable is only populated by runtime(), unless overwrite of runtime() makes use of the variable
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 window.initializeWindow(800, 600); // call runtime window.runtime();
} // in order to utilize function must use inheritance
void AppWindow::func(){ // retrieve length of frame double frame_length = getFrameDuration();
} used to retrieve the current frame
variable is only populated by runtime(), unless overwrite of runtime() makes use of the variable
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 window.initializeWindow(800, 600); // call runtime window.runtime();
} // in order to utilize function must use inheritance
void AppWindow::func(){ // retrieve length of frame double frame_length = getCurrentFrame();
} returns the current delta time
overwriting may need further modifications or accommodation to the update(), stepUpdate(), and render() as it may cause unintended behavior
void func(){ // obtain the deltatime float dt = window.getDeltaTime(); // example: use deltatime to have smooth vector translation player.position.x = movement * dt;
} returns the width of the window
when initializeWindow() is not called, this functions returns 0
void func(){ // obtain the width of the window unsigned int w = window.getWidth();
} returns the Height of the window
when initializeWindow() is not called, this functions returns 0
void func(){ // obtain the height of the window unsigned int w = window.getHeight();
} returns reference to the event handle
the returned reference gets updated through runtime()
void func(){ // get reference of the event handle SDL_Event&amp; event = window.getEventState(); // example: check for a mouse motion event // refer to SDL documentation if(event.type == SDL_MOUSEMOTION){ // do something... }
} <br>returns a keyboard state holder, refer to <a data-href="SDL keyboard" href="engine/input/src/sdl-keyboard.html" class="internal-link" target="_self" rel="noopener nofollow">SDL keyboard</a>
the keyboard state holder can be used to check which keyboard key was pressed
gets update by runtime()
void func(){ // obtain the keyboard state holder KeyboardStateHolder* state = window.getKeyboardState();
} used to grab reference to the window handle context
returns SDL_Window* created from initializeWindow(), else returns nullptr when initializeWindow() is never called
void func(){ // grab reference to the window handle SDL_Window* handle = window.getWindowHandle(); // example: use sdl handle to change window flag to maximize window // refer to SDL documentation SDL_MaximizeWindow(handle);
} used to initialize the window and it's contexts by default initializes SDL and creates a Window with OpenGL 4.5 capabilities
sets the window handle context which can be retrieved
the last parameter, const char*, gives the window a name which is optional
during initialization it calls additionalWindowOptions() and setUpOpenGL()
overwriting is not recommended, however due note that runtime(), getDeltaTime(), setUpOpenGL() require SDL to be initialized and have a created window handle context
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 window.initializeWindow(800, 600);
} // *Alternative*
void func(){ // create a class object that inherits from Window AppWindow window; // initialize the window with a size of 800x600 with a name window.initializeWindow(800, 600, "My App");
} used to call functions that handle the loading of shaders, textures, and objects
must at least be called once
// in order to utilize function must use inheritance
void AppWindow::init(){ // example: initialize a player object player.init();
} used to update Physics, ticks systems, or other at a fixed time step
the parameter of double is the calculate fixed time step value
// in order to utilize function must use inheritance
void AppWindow::stepUpdate(double ts){ // example: make a position vector move left over time position.x += 5.0f * ts
} used to update logic, custom events, and other at the target time step
// in order to utilize function must use inheritance
void AppWindow::update(){ // example: check a list of player of which one is not alive for(auto&amp; plr: players){ if(plr.isAlive == false){ //do something... } }
} used to render things on the screen
the parameter is used for linear interpolation to render things smoothly no matter the target time step
#include &lt;engine/sprite_renderer.hpp&gt; // in order to utilize function must use inheritance
void AppWindow::render(double alpha){ // example: flush all acumulated quads SpriteRenderer::FlushQuads();
} calls Init() once, then loops through getDeltaTime(), update(), stepUpdate(), and render()
in addition it calls calls SDL poll events, checks for SDL window events, swap buffers and clears the OpenGL color buffer
if overwritten, may need to apply calculations of time step, fixed time step and accumulator yourself
void func(){ // call runtime window.runtime();
}
]]></description><link>engine/window/src/window-sdl.html</link><guid isPermaLink="false">Engine/Window/src/Window-SDL.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Tutorial]]></title><description><![CDATA[(This page should show a step buy step on how to create a very simple game that uses all modules of the engine)]]></description><link>tutorial/tutorial.html</link><guid isPermaLink="false">Tutorial/Tutorial.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Usage]]></title><description><![CDATA[This page will explain how to set up the engine and get a working blank program ]]></description><link>usage/usage.html</link><guid isPermaLink="false">Usage/Usage.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[quad]]></title><description><![CDATA[<img src="engine/engine/src/images/quad.png" target="_self">]]></description><link>engine/engine/src/images/quad.html</link><guid isPermaLink="false">Engine/Engine/src/images/quad.png</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate><enclosure url="engine/engine/src/images/quad.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;engine/engine/src/images/quad.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[quadwire]]></title><description><![CDATA[<img src="engine/engine/src/images/quadwire.png" target="_self">]]></description><link>engine/engine/src/images/quadwire.html</link><guid isPermaLink="false">Engine/Engine/src/images/quadwire.png</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate><enclosure url="engine/engine/src/images/quadwire.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;engine/engine/src/images/quadwire.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GLFW Gamepad]]></title><description><![CDATA[The gamepad Input for GLFW is made available to be utilized when creating a a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>Refer to GLFW documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/" target="_self">https://www.glfw.org/docs/latest/</a> <br>When creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>, calling the default runtime(), and using the window paradigm. You can already utilize the keyboard input functions.
DISCLAIMER: overriding runtime() means you have to figure out how to check for input on your own and as well renders this page meaningless to read<br>To make a selection of a library to allow for input you must make use of their designated namespace. As well due note that you cannot mix library selection between <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> and <a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a> as it make cause definition errors thus you must have the same library selection throughout the whole application when using the engine // example of selecting a library // choosing to use GLFW
using namespace GLFW; // call GLFW specific function
getButtonInput(...); // alternative // call GLFW specific function using the namespace
GLFW::getButtonInput(...);
<br>You need to call <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> "runtime()" in order for checking for events detected such as when connecting or disconnecting a controller by the library selected like either GLFW or SDL.<br>Once the <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> is initialized you must then create a "Gamepad" component to then be able to check for input from that componentvoid AppWindow::update(){ // create gamepad component using GLFW as an example (similar when using SDL) GLFW::Gamepad pad; // queue the created gamepad to be set GLFW::SetGamepad(&amp;pad); // example: get input from gamepad if set if(GLFW::getButtonInput(pad, PLAYSTATION_BUTTON_SQUARE)){ // do something... }
}
Lastly, when connecting a game controller, the "Gamepad" component should have its "isConnected" flag boolean should be true meaning its been set successfully. Then you can then use the input functions which are named the same for both libraries, GLFW or SDL. To refer to a button or joystick from a controller you can check the commercial controller button and joystick macros or the engine's universal macrosFor using GLFW macros:
<br>For buttons refer to GLFW Documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/group__gamepad__buttons.html" target="_self">https://www.glfw.org/docs/latest/group__gamepad__buttons.html</a>
<br>For joysticks refer to GLFW Documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/group__gamepad__axes.html" target="_self">https://www.glfw.org/docs/latest/group__gamepad__axes.html</a>
void AppWindow::update(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(GLFW::getButtonInput(&amp;pad, GLFW_GAMEPAD_BUTTON_A)){ // do something... } // example: checking for axis input if(GLFW::getAxisInput(&amp;pad, GLFW_GAMEPAD_AXIS_LEFT_X) &gt; 0.0f){ // do something... }
}
For using Framework macros:void AppWindow::update(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(GLFW::getButtonInput(&amp;pad, SISTER_BUTTON_SOUTH)){ // do something... } // example: checking for axis input if(GLFW::getAxisInput(&amp;pad, SISTER_JOYSTICK_LEFT_X) &gt; 0.0f){ // do something... }
}
There is also available, if it makes it easier to read, platform specific macros are also provided from the Framework macros as wellvoid AppWindow::update(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(GLFW::getButtonInput(&amp;pad, PLAYSTATION_BUTTON_SQUARE)){ // do something... } // example: checking for axis input if(GLFW::getAxisInput(&amp;pad, XBOX_RIGHT_TRIGGER) &gt; 0.0f){ // do something... }
}
Header location:#include &lt;input/sisters_glfw_gamepad.hpp&gt; namespace GLFW{
...
}
List of all defined framework input macros defined for each of the buttons and joystick on a gamepad//? Engine specific button macros #define SISTER_BUTTON_SOUTH 0
#define SISTER_BUTTON_EAST 1
#define SISTER_BUTTON_WEST 2
#define SISTER_BUTTON_NORTH 3
#define SISTER_BUTTON_LEFT_BUMPER 4
#define SISTER_BUTTON_RIGHT_BUMPER 5
#define SISTER_BUTTON_BACK 6
#define SISTER_BUTTON_START 7
#define SISTER_BUTTON_GUIDE 8
#define SISTER_BUTTON_LEFT_THUMB 9
#define SISTER_BUTTON_RIGHT_THUMB 10
#define SISTER_BUTTON_DPAD_UP 11
#define SISTER_BUTTON_DPAD_RIGHT 12
#define SISTER_BUTTON_DPAD_DOWN 13
#define SISTER_BUTTON_DPAD_LEFT 14 #define SISTER_JOYSTICK_LEFT_X 0
#define SISTER_JOYSTICK_LEFT_Y 1
#define SISTER_JOYSTICK_RIGHT_X 2
#define SISTER_JOYSTICK_RIGHT_Y 3
#define SISTER_LEFT_TRIGGER 4
#define SISTER_RIGHT_TRIGGER 5 //? Playstation specific button macros #define PLAYSTATION_BUTTON_CROSS 0
#define PLAYSTATION_BUTTON_CIRCLE 1
#define PLAYSTATION_BUTTON_SQUARE 2
#define PLAYSTATION_BUTTON_TRIANGLE 3
#define PLAYSTATION_BUTTON_L1 4
#define PLAYSTATION_BUTTON_R1 5
#define PLAYSTATION_BUTTON_SELECT 6
#define PLAYSTATION_BUTTON_START 7
#define PLAYSTATION_BUTTON_PS 8
#define PLAYSTATION_BUTTON_L3 9
#define PLAYSTATION_BUTTON_R3 10
#define PLAYSTATION_BUTTON_DPAD_UP 11
#define PLAYSTATION_BUTTON_DPAD_RIGHT 12
#define PLAYSTATION_BUTTON_DPAD_DOWN 13
#define PLAYSTATION_BUTTON_DPAD_LEFT 14 #define PLAYSTATION_JOYSTICK_LEFT_X 0
#define PLAYSTATION_JOYSTICK_LEFT_Y 1
#define PLAYSTATION_JOYSTICK_RIGHT_X 2
#define PLAYSTATION_JOYSTICK_RIGHT_Y 3
#define PLAYSTATION_L2_TRIGGER_LEFT 4
#define PLAYSTATION_R2_TRIGGER_RIGHT 5 //? Xbox specific button macros #define XBOX_BUTTON_A 0
#define XBOX_BUTTON_B 1
#define XBOX_BUTTON_X 2
#define XBOX_BUTTON_Y 3
#define XBOX_BUTTON_LEFT_BUMPER 4
#define XBOX_BUTTON_RIGHT_BUMPER 5
#define XBOX_BUTTON_BACK 6
#define XBOX_BUTTON_START 7
#define XBOX_BUTTON_GUIDE 8
#define XBOX_BUTTON_LEFT_THUMB 9
#define XBOX_BUTTON_RIGHT_THUMB 10
#define XBOX_BUTTON_DPAD_UP 11
#define XBOX_BUTTON_DPAD_RIGHT 12
#define XBOX_BUTTON_DPAD_DOWN 13
#define XBOX_BUTTON_DPAD_LEFT 14 #define XBOX_JOYSTICK_LEFT_X 0
#define XBOX_JOYSTICK_LEFT_Y 1
#define XBOX_JOYSTICK_RIGHT_X 2
#define XBOX_JOYSTICK_RIGHT_Y 3
#define XBOX_LEFT_TRIGGER 4
#define XBOX_RIGHT_TRIGGER 5 //? Nintendo specific button macros #define NINTENDO_BUTTON_B 0
#define NINTENDO_BUTTON_A 1
#define NINTENDO_BUTTON_Y 2
#define NINTENDO_BUTTON_X 3
#define NINTENDO_BUTTON_LEFT_BUMPER 4
#define NINTENDO_BUTTON_RIGHT_BUMPER 5
#define NINTENDO_BUTTON_MINUS 6
#define NINTENDO_BUTTON_PLUS 7
#define NINTENDO_BUTTON_GUIDE 8
#define NINTENDO_BUTTON_LEFT_THUMB 9
#define NINTENDO_BUTTON_RIGHT_THUMB 10
#define NINTENDO_BUTTON_DPAD_UP 11
#define NINTENDO_BUTTON_DPAD_RIGHT 12
#define NINTENDO_BUTTON_DPAD_DOWN 13
#define NINTENDO_BUTTON_DPAD_LEFT 14 #define NINTENDO_JOYSTICK_LEFT_X 0
#define NINTENDO_JOYSTICK_LEFT_Y 1
#define NINTENDO_JOYSTICK_RIGHT_X 2
#define NINTENDO_JOYSTICK_RIGHT_Y 3
#define NINTENDO_LEFT_TRIGGER 4
#define NINTENDO_RIGHT_TRIGGER 5 //? Generic specific button macros
#define GENERIC_GLOBAL_BUTTON_LAST 14 returns number of devices that identify as "gamepads" otherwise known as game controllers
this only returns the number of gamepads that are connected
void func(){ // get amount of gamepads connected int amount = GLFW::getGamepadAmount();
} add a gamepad reference that can be filled from the list of queried gamepads
by default the index is 0 which picks the first gamepad set to be set, any other number is causes the gamepad to be set later until a gamepad with index of 0 is set
Gamepad component is set the moment a valid controller is connected either at start of application or during runtime
// assuming this functional gets called through the window paradigm
void func(){ // create gamepad component using GLFW as an example (similar when using SDL) GLFW::Gamepad pad; // queue the created gamepad to be set GLFW::setGamepad(&amp;pad);
} button callback of the gamepad which checks for the given button
requires a set gamepad
void func(){ //** Assuming the gamepad is set // example: checking for button input if(GLFW::getButtonInput(&amp;pad, PLAYSTATION_BUTTON_SQUARE)){ // do something... }
} axis callback of the gamepad which returns a incremental value when there is input of the given key
requires a set gamepad
the value returned is a floating number within in the range from -1.0f to 1.0f
by default the deadzone value is 0.5f and the valid range for deadzone is 0.0f to 1.0f
void func(){ //** Assuming the gamepad is set // example: checking for axis input if(GLFW::getAxisRawInput(&amp;pad, XBOX_RIGHT_TRIGGER) &gt; 0.0f){ // do something... } /*Alternative*/ // get the value of the direction obtain from the axis input float direction = GLFW::getAxisRawInput(&amp;pad, SISTER_JOYSTICK_LEFT_X); // example: use the direction with the movement movement = direction * speed;
} axis callback of the gamepad which returns a incremental value when there is input of the given key
requires a set gamepad
the value returned is a whole number within in the range from -1.0f to 1.0f
by default the deadzone value is 0.5f and the valid range for deadzone is 0.0f to 1.0f
void func(){ //** Assuming the gamepad is set // example: checking for axis input if(GLFW::getAxisInput(&amp;pad, XBOX_RIGHT_TRIGGER) &gt; 0.0f){ // do something... } /*Alternative*/ // get the value of the direction obtain from the axis input float direction = GLFW::getAxisInput(&amp;pad, SISTER_JOYSTICK_LEFT_X); // example: use the direction with the movement movement = direction * speed;
}
]]></description><link>engine/input/src/glfw-gamepad.html</link><guid isPermaLink="false">Engine/Input/src/GLFW Gamepad.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[GLFW keyboard]]></title><description><![CDATA[The Keyboard Input for GLFW is made available to be utilized when creating a a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>Refer to GLFW documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/" target="_self">https://www.glfw.org/docs/latest/</a> <br>When creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>, calling the default "runtime()", and using the window paradigm. You can already utilize the keyboard input functions.
DISCLAIMER: overriding "runtime()" means you have to figure out how to check for input on your own and as well renders this page meaningless to read<br>To make a selection of a library to allow for input you must make use of their designated namespace. As well due note that you cannot mix library selection between <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> and <a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a> as it make cause definition errors thus you must have the same library selection throughout the whole application when using the engine // example of selecting a library // choosing to use GLFW
using namespace GLFW; // call GLFW specific function
getKeyInput(...); // alternative // call GLFW specific function using the namespace
GLFW::getKeyInput(...);
When using the keyboard input functions you are allowed to use macros from both official GLFW or Framework.For GLFW keyboard,<br>
refer to GLFW keyboard tokens: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/3.3/group__keys.html" target="_self">https://www.glfw.org/docs/3.3/group__keys.html</a>void AppWindow::update(){ // check for input from the 'D' key of the keyboard if(GLFW::getKeyInput(GLFW_KEY_D)){ // do something... }
}
For using Framework macros:void AppWindow::update(){ // check for input from the 'D' key of the keyboard if(GLFW::getKeyInput(SISTERS_KEY_D)){ // do something... }
}
Header location:#include &lt;input/sisters_glfw_keyboard.hpp&gt; namespace GLFW{
...
}
<br>List of all defined framework input macros defined for each of the keys on the keyboard, be warned the key codes are from the US keyboard layout, refer to GLFW documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/" target="_self">https://www.glfw.org/docs/latest/</a> #define SISTER_KEY_SPACE 32
#define SISTER_KEY_APOSTROPHE 39 /* ' */
#define SISTER_KEY_COMMA 44 /* , */
#define SISTER_KEY_MINUS 45 /* - */
#define SISTER_KEY_PERIOD 46 /* . */
#define SISTER_KEY_SLASH 47 /* / */
#define SISTER_KEY_0 48
#define SISTER_KEY_1 49
#define SISTER_KEY_2 50
#define SISTER_KEY_3 51
#define SISTER_KEY_4 52
#define SISTER_KEY_5 53
#define SISTER_KEY_6 54
#define SISTER_KEY_7 55
#define SISTER_KEY_8 56
#define SISTER_KEY_9 57
#define SISTER_KEY_SEMICOLON 59 /* ; */
#define SISTER_KEY_EQUAL 61 /* = */
#define SISTER_KEY_A 65
#define SISTER_KEY_B 66
#define SISTER_KEY_C 67
#define SISTER_KEY_D 68
#define SISTER_KEY_E 69
#define SISTER_KEY_F 70
#define SISTER_KEY_G 71
#define SISTER_KEY_H 72
#define SISTER_KEY_I 73
#define SISTER_KEY_J 74
#define SISTER_KEY_K 75
#define SISTER_KEY_L 76
#define SISTER_KEY_M 77
#define SISTER_KEY_N 78
#define SISTER_KEY_O 79
#define SISTER_KEY_P 80
#define SISTER_KEY_Q 81
#define SISTER_KEY_R 82
#define SISTER_KEY_S 83
#define SISTER_KEY_T 84
#define SISTER_KEY_U 85
#define SISTER_KEY_V 86
#define SISTER_KEY_W 87
#define SISTER_KEY_X 88
#define SISTER_KEY_Y 89
#define SISTER_KEY_Z 90
#define SISTER_KEY_LEFT_BRACKET 91 /* [ */
#define SISTER_KEY_BACKSLASH 92 /* \ */
#define SISTER_KEY_RIGHT_BRACKET 93 /* ] */
#define SISTER_KEY_GRAVE_ACCENT 96 /* ` */
#define SISTER_KEY_WORLD_1 161 /* non-US #1 */
#define SISTER_KEY_WORLD_2 162 /* non-US #2 */
#define SISTER_KEY_ESCAPE 256
#define SISTER_KEY_ENTER 257
#define SISTER_KEY_TAB 258
#define SISTER_KEY_BACKSPACE 259
#define SISTER_KEY_INSERT 260
#define SISTER_KEY_DELETE 261
#define SISTER_KEY_RIGHT 262
#define SISTER_KEY_LEFT 263
#define SISTER_KEY_DOWN 264
#define SISTER_KEY_UP 265
#define SISTER_KEY_PAGE_UP 266
#define SISTER_KEY_PAGE_DOWN 267
#define SISTER_KEY_HOME 268
#define SISTER_KEY_END 269
#define SISTER_KEY_CAPS_LOCK 280
#define SISTER_KEY_SCROLL_LOCK 281
#define SISTER_KEY_NUM_LOCK 282
#define SISTER_KEY_PRINT_SCREEN 283
#define SISTER_KEY_PAUSE 284
#define SISTER_KEY_F1 290
#define SISTER_KEY_F2 291
#define SISTER_KEY_F3 292
#define SISTER_KEY_F4 293
#define SISTER_KEY_F5 294
#define SISTER_KEY_F6 295
#define SISTER_KEY_F7 296
#define SISTER_KEY_F8 297
#define SISTER_KEY_F9 298
#define SISTER_KEY_F10 299
#define SISTER_KEY_F11 300
#define SISTER_KEY_F12 301
#define SISTER_KEY_F13 302
#define SISTER_KEY_F14 303
#define SISTER_KEY_F15 304
#define SISTER_KEY_F16 305
#define SISTER_KEY_F17 306
#define SISTER_KEY_F18 307
#define SISTER_KEY_F19 308
#define SISTER_KEY_F20 309
#define SISTER_KEY_F21 310
#define SISTER_KEY_F22 311
#define SISTER_KEY_F23 312
#define SISTER_KEY_F24 313
#define SISTER_KEY_F25 314
#define SISTER_KEY_KP_0 320
#define SISTER_KEY_KP_1 321
#define SISTER_KEY_KP_2 322
#define SISTER_KEY_KP_3 323
#define SISTER_KEY_KP_4 324
#define SISTER_KEY_KP_5 325
#define SISTER_KEY_KP_6 326
#define SISTER_KEY_KP_7 327
#define SISTER_KEY_KP_8 328
#define SISTER_KEY_KP_9 329
#define SISTER_KEY_KP_DECIMAL 330
#define SISTER_KEY_KP_DIVIDE 331
#define SISTER_KEY_KP_MULTIPLY 332
#define SISTER_KEY_KP_SUBTRACT 333
#define SISTER_KEY_KP_ADD 334
#define SISTER_KEY_KP_ENTER 335
#define SISTER_KEY_KP_EQUAL 336
#define SISTER_KEY_LEFT_SHIFT 340
#define SISTER_KEY_LEFT_CONTROL 341
#define SISTER_KEY_LEFT_ALT 342
#define SISTER_KEY_LEFT_SUPER 343
#define SISTER_KEY_RIGHT_SHIFT 344
#define SISTER_KEY_RIGHT_CONTROL 345
#define SISTER_KEY_RIGHT_ALT 346
#define SISTER_KEY_RIGHT_SUPER 347
#define SISTER_KEY_MENU 348
#define SISTER_KEY_LAST SISTER_KEY_MENU key callback of the keyboard which checks for the given key
checks if key was pressed
void func(){ // initialize keyboard manager // check for input, example: check for the A key if(GLFW::getKeyInput(SISTER_KEY_A)){ // do something... }
} key callback of the keyboard which checks for the given key
checks if key was pressed similar to getKeyInput()
void func(){ // initialize keyboard manager // check for input, example: check for the A key if(GLFW::getKeyInputDown(SISTER_KEY_A)){ // do something... }
} key callback of the keyboard which checks for the given key
checks if key was released or not being pressed
void func(){ // initialize keyboard manager // check for input, example: check for the A key is not being pressed if(GLFW::getKeyInputUp(SISTER_KEY_A)){ // do something... }
}
]]></description><link>engine/input/src/glfw-keyboard.html</link><guid isPermaLink="false">Engine/Input/src/GLFW keyboard.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[GLFW Mouse]]></title><description><![CDATA[The Mouse input for GLFW is made available to be utilized when creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>Refer to GLFW documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/" target="_self">https://www.glfw.org/docs/latest/</a> <br>When creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>, calling the default "runtime()", and using the window paradigm. You can already utilize the mouse functions.
DISCLAIMER: overriding "runtime()" means you have to figure out how to check for input on your own and as well renders this page meaningless to read<br>To make a selection of a library to allow for input you must make use of their designated namespace. As well due note that you cannot mix library selection between <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> and <a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a> as it make cause definition errors thus you must have the same library selection throughout the whole application when using the engine // example of selecting a library // choosing to use GLFW
using namespace GLFW; // call GLFW specific function
getMousePosition(...); // alternative // call GLFW specific function using the namespace
GLFW::getMousePosition(...);
<br>It is also imperative to mentions about the input from the scroll wheel so when there's scroll wheel input moves it is set to the maximum value like 1.5f and the direction is also given by forward scroll being positive and backward scroll being negative and <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> "runtime()" in the default definition handles slowing down the scroll wheel received input to zero at a rate which can be changed by calling some functions in <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>. When using the mouse button input function you are allowed to to use macros from both official GLFW or Framework provide macros.For using GLFW macros:
<br>For mouse buttons refer to GLFW Documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/group__buttons.html" target="_self">https://www.glfw.org/docs/latest/group__buttons.html</a>
void AppWindow::update(){ // check for input from the left mouse button if(GLFW::getMouseInput(GLFW_MOUSE_BUTTON_LEFT)){ // do something... }
}
For using Framework macros:void AppWindow::update(){ // check for input from the left mouse button if(GLFW::getMouseInput(SISTER_MOUSE_BUTTON_LEFT)){ // do something... }
}
Header location: #include &lt;input/sisters_glfw_mouse.hpp namespace GLFW{
...
}
List of all defined framework mouse button input macros defined for each of the buttons on a mouse//? Engine renamed mouse scancode to allow for mouse inputs #define SISTER_MOUSE_BUTTON_LEFT 0
#define SISTER_MOUSE_BUTTON_RIGHT 1
#define SISTER_MOUSE_BUTTON_MIDDLE 2
#define SISTER_MOUSE_BUTTON_X1 3
#define SISTER_MOUSE_BUTTON_X2 4
#define SISTER_MOUSE_BUTTON_X3 5
#define SISTER_MOUSE_BUTTON_X4 6
#define SISTER_MOUSE_BUTTON_X5 7 used to check the current mouse position within the window area
if the mouse cursor is outside the window area, the default returned value will be what it was last
the position starts from the Top Left corner of the window area
void func(){ // variables containing positions of the mouse double x, y; // get the mouse position GLFW::getMousePosition(&amp;x, &amp;y); // variable "x" and "y" now contain the position of the mouse
} used to check for the mouse button input
when the mouse cursor is outside the window area, the default returned value is false
void func(){ // check for mouse right button press if(GLFW::getMouseInput(GLFW_MOUSE_BUTTON_RIGHT)){ // do something.. } // alternative // check for mouse right button press if(GLFW::getMouseInput(SISTER_MOUSE_BUTTON_RIGHT)){ // do something.. }
} used to get the raw value of the vertical mouse wheel input
the value returned has a direction being forward scroll being positive and backward scroll being negative
<br>due note that after receiving input, slowly by frame it is set to zero by <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> by "runtime()" default definition
void func(){ // get the raw mouse wheel input double wheel_y = GLFW::getMouseWheelYRaw();
} used to get any input from the vertical mouse wheel input
the value returned gives no direction
<br>due note that after receiving input, slowly by frame it is set to zero by <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> by "runtime()" default definition
void func(){ // get the mouse wheel input bool wheel_y = GLFW::getMouseWheelY();
} used to get the status of the mouse cursor if it's within the window area
void func(){ // check if the mouse is within the window area if(GLFW::getMouseFocus()){ // do something... }
}
]]></description><link>engine/input/src/glfw-mouse.html</link><guid isPermaLink="false">Engine/Input/src/GLFW Mouse.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[SDL Gamepad]]></title><description><![CDATA[The gamepad Input for SDL is made available to be utilized when creating a a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>Refer to SDL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/FrontPage" target="_self">https://wiki.libsdl.org/SDL3/FrontPage</a>
<br>When creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>, calling the default runtime(), and using the window paradigm. You can already utilize the keyboard input functions.
DISCLAIMER: overriding runtime() means you have to figure out how to check for input on your own and as well renders this page meaningless to read<br>To make a selection of a library to allow for input you must make use of their designated namespace. As well due note that you cannot mix library selection between <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> and <a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a> as it make cause definition errors thus you must have the same library selection throughout the whole application when using the engine // example of selecting a library // choosing to use SDL
using namespace SDL; // call SDL specific function
getButtonInput(...); // alternative // call SDL specific function using the namespace
SDL::getButtonInput(...);
<br>You need to call <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> "runtime()" in order for checking for events detected such as when connecting or disconnecting a controller by the library selected like either GLFW or SDL.<br>Once the <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> is initialized you must then create a "Gamepad" component to then be able to check for input from that componentvoid func(){ // create gamepad component using SDL as an example (similar when using SDL) SDL::Gamepad pad; // queue the created gamepad to be set SDL::SetGamepad(&amp;pad);
}
Lastly, when connecting a game controller, the "Gamepad" component should have its "isConnected" flag boolean should be true meaning its been set successfully. Then you can then use the input functions which are named the same for both libraries, GLFW or SDL. To refer to a button or joystick from a controller you can check the commercial controller button and joystick macros or the engine's universal macrosFor using SDL macros:
<br>For buttons refer to SDL Documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/SDL_GamepadButton" target="_self">https://wiki.libsdl.org/SDL3/SDL_GamepadButton</a> <br>For axis refer to SDL Documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/SDL_GamepadAxis" target="_self">https://wiki.libsdl.org/SDL3/SDL_GamepadAxis</a>
void func(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(SDL::getButtonInput(&amp;pad, SDL_GAMEPAD_BUTTON_SOUTH)){ // do something... } // example: checking for axis input if(SDL::getAxisInput(&amp;pad, SDL_GAMEPAD_AXIS_LEFTX) &gt; 0.0f){ // do something... }
}
For using Framework macros:void func(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(SDL::getButtonInput(&amp;pad, SISTER_BUTTON_SOUTH)){ // do something... } // example: checking for axis input if(SDL::getAxisInput(&amp;pad, SISTER_JOYSTICK_LEFT_X) &gt; 0.0f){ // do something... }
}
There is also available, if it makes it easier to read, platform specific macros also provided from the Framework macros as wellvoid func(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(SDL::getButtonInput(&amp;pad, PLAYSTATION_BUTTON_SQUARE)){ // do something... } // example: checking for axis input if(SDL::getAxisInput(&amp;pad, XBOX_RIGHT_TRIGGER) &gt; 0.0f){ // do something... }
}
Header location:#include &lt;input/sisters_sdl_gamepad.hpp&gt; namespace SDL{
...
}
List of all defined framework input macros defined for each of the buttons and joystick on a gamepad//? Engine specific button macros #define SISTER_BUTTON_SOUTH 0
#define SISTER_BUTTON_EAST 1
#define SISTER_BUTTON_WEST 2
#define SISTER_BUTTON_NORTH 3
#define SISTER_BUTTON_LEFT_BUMPER 4
#define SISTER_BUTTON_RIGHT_BUMPER 5
#define SISTER_BUTTON_BACK 6
#define SISTER_BUTTON_START 7
#define SISTER_BUTTON_GUIDE 8
#define SISTER_BUTTON_LEFT_THUMB 9
#define SISTER_BUTTON_RIGHT_THUMB 10
#define SISTER_BUTTON_DPAD_UP 11
#define SISTER_BUTTON_DPAD_RIGHT 12
#define SISTER_BUTTON_DPAD_DOWN 13
#define SISTER_BUTTON_DPAD_LEFT 14 #define SISTER_JOYSTICK_LEFT_X 0
#define SISTER_JOYSTICK_LEFT_Y 1
#define SISTER_JOYSTICK_RIGHT_X 2
#define SISTER_JOYSTICK_RIGHT_Y 3
#define SISTER_LEFT_TRIGGER 4
#define SISTER_RIGHT_TRIGGER 5 //? Playstation specific button macros #define PLAYSTATION_BUTTON_CROSS 0
#define PLAYSTATION_BUTTON_CIRCLE 1
#define PLAYSTATION_BUTTON_SQUARE 2
#define PLAYSTATION_BUTTON_TRIANGLE 3
#define PLAYSTATION_BUTTON_L1 4
#define PLAYSTATION_BUTTON_R1 5
#define PLAYSTATION_BUTTON_SELECT 6
#define PLAYSTATION_BUTTON_START 7
#define PLAYSTATION_BUTTON_PS 8
#define PLAYSTATION_BUTTON_L3 9
#define PLAYSTATION_BUTTON_R3 10
#define PLAYSTATION_BUTTON_DPAD_UP 11
#define PLAYSTATION_BUTTON_DPAD_RIGHT 12
#define PLAYSTATION_BUTTON_DPAD_DOWN 13
#define PLAYSTATION_BUTTON_DPAD_LEFT 14 #define PLAYSTATION_JOYSTICK_LEFT_X 0
#define PLAYSTATION_JOYSTICK_LEFT_Y 1
#define PLAYSTATION_JOYSTICK_RIGHT_X 2
#define PLAYSTATION_JOYSTICK_RIGHT_Y 3
#define PLAYSTATION_L2_TRIGGER_LEFT 4
#define PLAYSTATION_R2_TRIGGER_RIGHT 5 //? Xbox specific button macros #define XBOX_BUTTON_A 0
#define XBOX_BUTTON_B 1
#define XBOX_BUTTON_X 2
#define XBOX_BUTTON_Y 3
#define XBOX_BUTTON_LEFT_BUMPER 4
#define XBOX_BUTTON_RIGHT_BUMPER 5
#define XBOX_BUTTON_BACK 6
#define XBOX_BUTTON_START 7
#define XBOX_BUTTON_GUIDE 8
#define XBOX_BUTTON_LEFT_THUMB 9
#define XBOX_BUTTON_RIGHT_THUMB 10
#define XBOX_BUTTON_DPAD_UP 11
#define XBOX_BUTTON_DPAD_RIGHT 12
#define XBOX_BUTTON_DPAD_DOWN 13
#define XBOX_BUTTON_DPAD_LEFT 14 #define XBOX_JOYSTICK_LEFT_X 0
#define XBOX_JOYSTICK_LEFT_Y 1
#define XBOX_JOYSTICK_RIGHT_X 2
#define XBOX_JOYSTICK_RIGHT_Y 3
#define XBOX_LEFT_TRIGGER 4
#define XBOX_RIGHT_TRIGGER 5 //? Nintendo specific button macros #define NINTENDO_BUTTON_B 0
#define NINTENDO_BUTTON_A 1
#define NINTENDO_BUTTON_Y 2
#define NINTENDO_BUTTON_X 3
#define NINTENDO_BUTTON_LEFT_BUMPER 4
#define NINTENDO_BUTTON_RIGHT_BUMPER 5
#define NINTENDO_BUTTON_MINUS 6
#define NINTENDO_BUTTON_PLUS 7
#define NINTENDO_BUTTON_GUIDE 8
#define NINTENDO_BUTTON_LEFT_THUMB 9
#define NINTENDO_BUTTON_RIGHT_THUMB 10
#define NINTENDO_BUTTON_DPAD_UP 11
#define NINTENDO_BUTTON_DPAD_RIGHT 12
#define NINTENDO_BUTTON_DPAD_DOWN 13
#define NINTENDO_BUTTON_DPAD_LEFT 14 #define NINTENDO_JOYSTICK_LEFT_X 0
#define NINTENDO_JOYSTICK_LEFT_Y 1
#define NINTENDO_JOYSTICK_RIGHT_X 2
#define NINTENDO_JOYSTICK_RIGHT_Y 3
#define NINTENDO_LEFT_TRIGGER 4
#define NINTENDO_RIGHT_TRIGGER 5 //? Generic specific button macros
#define GENERIC_GLOBAL_BUTTON_LAST 14 returns number of devices that identify as "gamepads" otherwise known as game controllers
this only returns the number of gamepads that are connected
void func(){ // get amount of gamepads connected int amount = SDL::getGamepadAmount();
} add a gamepad reference that can be filled from the list of queried gamepads
by default the index is 0 which picks the first gamepad set to be set, any other number is causes the gamepad to be set later until a gamepad with index of 0 is set
Gamepad component is set the moment a valid controller is connected either at start of application or during runtime
// assuming this functional gets called through the window paradigm
void func(){ // create gamepad component using SDL as an example (similar when using SDL) SDL::Gamepad pad; // queue the created gamepad to be set SDL::setGamepad(&amp;pad);
} button callback of the gamepad which checks for the given button
requires a set gamepad
void func(){ //** Assuming the gamepad is set // example: checking for button input if(getButtonInput(&amp;pad, PLAYSTATION_BUTTON_SQUARE)){ // do something... }
} axis callback of the gamepad which returns a incremental value when there is input of the given key
requires a set gamepad
the value returned is a floating number within in the range from -1.0f to 1.0f
by default the deadzone value is 0.5f and the valid range for deadzone is 0.0f to 1.0f
void func(){ //** Assuming the gamepad is set // example: checking for axis input if(getAxisRawInput(&amp;pad, XBOX_RIGHT_TRIGGER) &gt; 0.0f){ // do something... } /*Alternative*/ // get the value of the direction obtain from the axis input float direction = getAxisRawInput(&amp;pad, SISTER_JOYSTICK_LEFT_X); // example: use the direction with the movement movement = direction * speed;
} axis callback of the gamepad which returns a incremental value when there is input of the given key
requires a set gamepad
the value returned is a whole number within in the range from -1.0f to 1.0f
by default the deadzone value is 0.5f and the valid range for deadzone is 0.0f to 1.0f
void func(){ //** Assuming the gamepad is set // example: checking for axis input if(SDL::getAxisInput(&amp;pad, XBOX_RIGHT_TRIGGER) &gt; 0.0f){ // do something... } /*Alternative*/ // get the value of the direction obtain from the axis input float direction = SDL::getAxisInput(&amp;pad, SISTER_JOYSTICK_LEFT_X); // example: use the direction with the movement movement = direction * speed;
}
]]></description><link>engine/input/src/sdl-gamepad.html</link><guid isPermaLink="false">Engine/Input/src/SDL Gamepad.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[SDL keyboard]]></title><description><![CDATA[The Keyboard Input for SDL is made available to be utilized when creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>Refer to SDL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/FrontPage" target="_self">https://wiki.libsdl.org/SDL3/FrontPage</a>
<br>When creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>, calling the default "runtime()", and using the window paradigm. You can already utilize the keyboard input functions.
DISCLAIMER: overriding "runtime()" means you have to figure out how to check for input on your own and as well renders this page meaningless to read<br>To make a selection of a library to allow for input you must make use of their designated namespace. As well due note that you cannot mix library selection between <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> and <a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a> as it make cause definition errors thus you must have the same library selection throughout the whole application when using the engine // example of selecting a library // choosing to use SDL
using namespace SDL; // call SDL specific function
getKeyInput(...); // alternative // call SDL specific function using the namespace
SDL::getKeyInput(...);
When using the keyboard input functions you are allowed to use macros from both official SDL or Framework provide macros.For SDL keyboard,<br>
refer to SDL keyboard tokens: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/SDL_Keycode" target="_self">https://wiki.libsdl.org/SDL3/SDL_Keycode</a>void AppWindow::update(){ // check for input from the 'D' key of the keyboard if(SDL::getKeyInput(SDLK_D)){ // do something... }
}
For using Framework macros:void AppWindow::update(){ // check for input from the 'D' key of the keyboard if(SDL::getKeyInput(SISTERS_KEY_D)){ // do something... }
}
Header location:#include &lt;input/sisters_SDL_keyboard.hpp&gt; namespace SDL{
...
}
<br>List of all defined framework input macros defined for each of the keys on the keyboard, be warned the key codes are from the US keyboard layout, refer to SDL documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/FrontPage" target="_self">https://wiki.libsdl.org/SDL3/FrontPage</a>#define SISTER_KEY_SPACE 32
#define SISTER_KEY_APOSTROPHE 39 /* ' */
#define SISTER_KEY_COMMA 44 /* , */
#define SISTER_KEY_MINUS 45 /* - */
#define SISTER_KEY_PERIOD 46 /* . */
#define SISTER_KEY_SLASH 47 /* / */
#define SISTER_KEY_0 48
#define SISTER_KEY_1 49
#define SISTER_KEY_2 50
#define SISTER_KEY_3 51
#define SISTER_KEY_4 52
#define SISTER_KEY_5 53
#define SISTER_KEY_6 54
#define SISTER_KEY_7 55
#define SISTER_KEY_8 56
#define SISTER_KEY_9 57
#define SISTER_KEY_SEMICOLON 59 /* ; */
#define SISTER_KEY_EQUAL 61 /* = */
#define SISTER_KEY_A 65
#define SISTER_KEY_B 66
#define SISTER_KEY_C 67
#define SISTER_KEY_D 68
#define SISTER_KEY_E 69
#define SISTER_KEY_F 70
#define SISTER_KEY_G 71
#define SISTER_KEY_H 72
#define SISTER_KEY_I 73
#define SISTER_KEY_J 74
#define SISTER_KEY_K 75
#define SISTER_KEY_L 76
#define SISTER_KEY_M 77
#define SISTER_KEY_N 78
#define SISTER_KEY_O 79
#define SISTER_KEY_P 80
#define SISTER_KEY_Q 81
#define SISTER_KEY_R 82
#define SISTER_KEY_S 83
#define SISTER_KEY_T 84
#define SISTER_KEY_U 85
#define SISTER_KEY_V 86
#define SISTER_KEY_W 87
#define SISTER_KEY_X 88
#define SISTER_KEY_Y 89
#define SISTER_KEY_Z 90
#define SISTER_KEY_LEFT_BRACKET 91 /* [ */
#define SISTER_KEY_BACKSLASH 92 /* \ */
#define SISTER_KEY_RIGHT_BRACKET 93 /* ] */
#define SISTER_KEY_GRAVE_ACCENT 96 /* ` */
#define SISTER_KEY_WORLD_1 161 /* non-US #1 */
#define SISTER_KEY_WORLD_2 162 /* non-US #2 */
#define SISTER_KEY_ESCAPE 256
#define SISTER_KEY_ENTER 257
#define SISTER_KEY_TAB 258
#define SISTER_KEY_BACKSPACE 259
#define SISTER_KEY_INSERT 260
#define SISTER_KEY_DELETE 261
#define SISTER_KEY_RIGHT 262
#define SISTER_KEY_LEFT 263
#define SISTER_KEY_DOWN 264
#define SISTER_KEY_UP 265
#define SISTER_KEY_PAGE_UP 266
#define SISTER_KEY_PAGE_DOWN 267
#define SISTER_KEY_HOME 268
#define SISTER_KEY_END 269
#define SISTER_KEY_CAPS_LOCK 280
#define SISTER_KEY_SCROLL_LOCK 281
#define SISTER_KEY_NUM_LOCK 282
#define SISTER_KEY_PRINT_SCREEN 283
#define SISTER_KEY_PAUSE 284
#define SISTER_KEY_F1 290
#define SISTER_KEY_F2 291
#define SISTER_KEY_F3 292
#define SISTER_KEY_F4 293
#define SISTER_KEY_F5 294
#define SISTER_KEY_F6 295
#define SISTER_KEY_F7 296
#define SISTER_KEY_F8 297
#define SISTER_KEY_F9 298
#define SISTER_KEY_F10 299
#define SISTER_KEY_F11 300
#define SISTER_KEY_F12 301
#define SISTER_KEY_F13 302
#define SISTER_KEY_F14 303
#define SISTER_KEY_F15 304
#define SISTER_KEY_F16 305
#define SISTER_KEY_F17 306
#define SISTER_KEY_F18 307
#define SISTER_KEY_F19 308
#define SISTER_KEY_F20 309
#define SISTER_KEY_F21 310
#define SISTER_KEY_F22 311
#define SISTER_KEY_F23 312
#define SISTER_KEY_F24 313
#define SISTER_KEY_F25 314
#define SISTER_KEY_KP_0 320
#define SISTER_KEY_KP_1 321
#define SISTER_KEY_KP_2 322
#define SISTER_KEY_KP_3 323
#define SISTER_KEY_KP_4 324
#define SISTER_KEY_KP_5 325
#define SISTER_KEY_KP_6 326
#define SISTER_KEY_KP_7 327
#define SISTER_KEY_KP_8 328
#define SISTER_KEY_KP_9 329
#define SISTER_KEY_KP_DECIMAL 330
#define SISTER_KEY_KP_DIVIDE 331
#define SISTER_KEY_KP_MULTIPLY 332
#define SISTER_KEY_KP_SUBTRACT 333
#define SISTER_KEY_KP_ADD 334
#define SISTER_KEY_KP_ENTER 335
#define SISTER_KEY_KP_EQUAL 336
#define SISTER_KEY_LEFT_SHIFT 340
#define SISTER_KEY_LEFT_CONTROL 341
#define SISTER_KEY_LEFT_ALT 342
#define SISTER_KEY_LEFT_SUPER 343
#define SISTER_KEY_RIGHT_SHIFT 344
#define SISTER_KEY_RIGHT_CONTROL 345
#define SISTER_KEY_RIGHT_ALT 346
#define SISTER_KEY_RIGHT_SUPER 347
#define SISTER_KEY_MENU 348
#define SISTER_KEY_LAST SISTER_KEY_MENU key callback of the keyboard which checks for the given key
checks if key was pressed
void func(){ // initialize keyboard manager // check for input, example: check for the A key if(SDL::getKeyInput(SISTER_KEY_A)){ // do something... }
} key callback of the keyboard which checks for the given key
checks if key was pressed similar to getKeyInput()
void func(){ // initialize keyboard manager // check for input, example: check for the A key if(SDL::getKeyInputDown(SISTER_KEY_A)){ // do something... }
} key callback of the keyboard which checks for the given key
checks if key was released or not being pressed
void func(){ // initialize keyboard manager // check for input, example: check for the A key is not being pressed if(SDL::getKeyInputUp(SISTER_KEY_A)){ // do something... }
}
]]></description><link>engine/input/src/sdl-keyboard.html</link><guid isPermaLink="false">Engine/Input/src/SDL keyboard.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[SDL Mouse]]></title><description><![CDATA[The Mouse input for SDL is made available to be utilized when creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>Refer to SDL documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/FrontPage" target="_self">https://wiki.libsdl.org/SDL3/FrontPage</a>
<br>When creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>, calling the default "runtime()", and using the window paradigm. You can already utilize the mouse functions.
DISCLAIMER: overriding "runtime()" means you have to figure out how to check for input on your own and as well renders this page meaningless to read<br>To make a selection of a library to allow for input you must make use of their designated namespace. As well due note that you cannot mix library selection between <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> and <a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a> as it make cause definition errors thus you must have the same library selection throughout the whole application when using the engine // example of selecting a library // choosing to use SDL
using namespace SDL; // call SDL specific function
getMousePosition(...); // alternative // call SDL specific function using the namespace
SDL::getMousePosition(...);
<br>It is also imperative to mentions about the input from the scroll wheel so when there's scroll wheel input moves it is set to the maximum value like 1.5f and the direction is also given by forward scroll being positive and backward scroll being negative and <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> "runtime()" in the default definition handles slowing down the scroll wheel received input to zero at a rate which can be changed by calling some functions in <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>. When using the mouse button input function you are allowed to to use macros from both official GLFW or Framework provide macros.For using GLFW macros:
<br>For mouse buttons refer to GLFW Documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/group__buttons.html" target="_self">https://www.glfw.org/docs/latest/group__buttons.html</a>
void AppWindow::update(){ // check for input from the left mouse button if(GLFW::getMouseInput(GLFW_MOUSE_BUTTON_LEFT)){ // do something... }
}
For using Framework macros:void AppWindow::update(){ // check for input from the left mouse button if(GLFW::getMouseInput(SISTER_MOUSE_BUTTON_LEFT)){ // do something... }
}
Header location: #include &lt;input/sisters_glfw_mouse.hpp namespace GLFW{
...
}
List of all defined framework mouse button input macros defined for each of the buttons on a mouse//? Engine renamed mouse scancode to allow for mouse inputs #define SISTER_MOUSE_BUTTON_LEFT 0
#define SISTER_MOUSE_BUTTON_RIGHT 1
#define SISTER_MOUSE_BUTTON_MIDDLE 2
#define SISTER_MOUSE_BUTTON_X1 3
#define SISTER_MOUSE_BUTTON_X2 4
#define SISTER_MOUSE_BUTTON_X3 5
#define SISTER_MOUSE_BUTTON_X4 6
#define SISTER_MOUSE_BUTTON_X5 7 used to check the current mouse position within the window area
if the mouse cursor is outside the window area, the default returned value will be what it was last
the position starts from the Top Left corner of the window area
void func(){ // variables containing positions of the mouse double x, y; // get the mouse position GLFW::getMousePosition(&amp;x, &amp;y); // variable "x" and "y" now contain the position of the mouse
} used to check for the mouse button input
when the mouse cursor is outside the window area, the default returned value is false
void func(){ // check for mouse right button press if(GLFW::getMouseInput(GLFW_MOUSE_BUTTON_RIGHT)){ // do something.. } // alternative // check for mouse right button press if(GLFW::getMouseInput(SISTER_MOUSE_BUTTON_RIGHT)){ // do something.. }
} used to get the raw value of the vertical mouse wheel input
the value returned has a direction being forward scroll being positive and backward scroll being negative
<br>due note that after receiving input, slowly by frame it is set to zero by <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> by "runtime()" default definition
void func(){ // get the raw mouse wheel input double wheel_y = GLFW::getMouseWheelYRaw();
} used to get any input from the vertical mouse wheel input
the value returned gives no direction
<br>due note that after receiving input, slowly by frame it is set to zero by <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> by "runtime()" default definition
void func(){ // get the mouse wheel input bool wheel_y = GLFW::getMouseWheelY();
} used to get the status of the mouse cursor if it's within the window area
void func(){ // check if the mouse is within the window area if(GLFW::getMouseFocus()){ // do something... }
}
]]></description><link>engine/input/src/sdl-mouse.html</link><guid isPermaLink="false">Engine/Input/src/SDL Mouse.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Input]]></title><description><![CDATA[The input system implementation within the <a data-href="3 Sisters-Framework-Engine" href="engine/3-sisters-framework-engine.html" class="internal-link" target="_self" rel="noopener nofollow">3 Sisters-Framework-Engine</a> is to allow for ease of use and global use, meaning you can check for input at later points in your code. DUE NOTE: there can be some differences between GLFW and SDL versions of input.Refer to GLFW documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/" target="_self">https://www.glfw.org/docs/latest/</a> Refer to SDL documentation: <br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/FrontPage" target="_self">https://wiki.libsdl.org/SDL3/FrontPage</a>
When creating a class that inherits from <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>, calling the default "runtime()", and using the window paradigm. You can already utilize the keyboard, mouse, and controller input functions.
DISCLAIMER: overriding "runtime()" means you have to figure out how to check for input on your own and as well renders this page meaningless to read <br>To make a selection of a library to allow for input, either GLFW or SDL, you must make use of their designated namespace. As well due note that you cannot mix library selection between <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> and <a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a> as it make cause definition errors thus you must have the same library selection throughout the whole application when using the engine // example of selecting a library // choosing to use GLFW
using namespace GLFW; // call GLFW specific function
getKeyInput(...); // alternative // call GLFW specific function using the namespace
GLFW::getKeyInput(...); // choosing to use SDL
using namespace SDL; // call SDL specific function
getKeyInput(...); // alternative // call SDL specific function using the namespace
SDL::getKeyInput(...);
<br>The keyboard input gets updated by <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> when running the "runtime()" which checks for IO events and without it you can't check for any input from the keyboard<br>For <a data-href="GLFW keyboard" href="engine/input/src/glfw-keyboard.html" class="internal-link" target="_self" rel="noopener nofollow">GLFW keyboard</a>,<br>
refer to GLFW keyboard tokens: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/3.3/group__keys.html" target="_self">https://www.glfw.org/docs/3.3/group__keys.html</a>void update(){ // check for input from the 'D' key of the keyboard if(GLFW::GetKeyInput(GLFW_KEY_D)){ // do something... }
}
<br>For <a data-href="SDL keyboard" href="engine/input/src/sdl-keyboard.html" class="internal-link" target="_self" rel="noopener nofollow">SDL keyboard</a>,<br>
refer to SDL keyboard scancode: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL2/SDL_Scancode" target="_self">https://wiki.libsdl.org/SDL2/SDL_Scancode</a> void update(){ // check for input from the 'D' key of the keyboard if(SDL::GetKeyInput(SDL_SCANCODE_D)){ // do something... }
}
For using engine macros:void update(){ // check for input from the 'D' key of the keyboard if(SDL::GetKeyInput(SISTERS_KEY_D)){ // do something... }
}
For Mouse inputs, work similarly to Keyboard inputs though DUE NOTE: there are few differences between SDL and GLFW versions though their functionality are exactly the same<br>The gamepad get updated by <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> when running the "runtime()" which checks for connected, disconnected, and input for any valid controller.<br>Similarly, once the <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> is initialized you must then create a "Gamepad" component to then be able to check for input from that componentvoid func(){ // create gamepad component using SDL as an example (similar when using SDL) SDL::Gamepad pad; // queue the created gamepad to be set SDL::SetGamepad(&amp;pad);
}
Lastly, when connecting a game controller, the "Gamepad" component should have its "isConnected" flag boolean should be true meaning its been set successfully. Then you can then use any input functions which are named the same for both libraries, GLFW or SDL. To refer to a button or joystick from a controller you can check the commercial controller button and joystick macros or the engine's universal macrosFor using GLFW macros:
<br>For buttons refer to GLFW Documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/group__gamepad__buttons.html" target="_self">https://www.glfw.org/docs/latest/group__gamepad__buttons.html</a>
<br>For axis refer to GLFW Documentation <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.glfw.org/docs/latest/group__gamepad__axes.html" target="_self">https://www.glfw.org/docs/latest/group__gamepad__axes.html</a>
For using SDL macros:
<br>For buttons refer to SDL Documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/SDL_GamepadButton" target="_self">https://wiki.libsdl.org/SDL3/SDL_GamepadButton</a> <br>For axis refer to SDL Documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.libsdl.org/SDL3/SDL_GamepadAxis" target="_self">https://wiki.libsdl.org/SDL3/SDL_GamepadAxis</a>
void func(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(SDL::getButtonInput(&amp;pad, SDL_GAMEPAD_BUTTON_SOUTH)){ // do something... } // example: checking for axis input if(SDL::getAxisInput(&amp;pad, SDL_GAMEPAD_AXIS_LEFTX) &gt; 0.0f){ // do something... }
}
For using Framework macros:void func(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(SDL::getButtonInput(&amp;pad, SISTER_BUTTON_SOUTH)){ // do something... } // example: checking for axis input if(SDL::getAxisInput(&amp;pad, SISTER_JOYSTICK_LEFT_X) &gt; 0.0f){ // do something... }
}
There is also available, if it makes it easier to read, platform specific macros also provided from the Framework macros as wellvoid func(){ // created a gamepad component // queue the created gamepad to be set //** Assuming a gamepad is connected and is set // example: checking for button input if(SDL::getButtonInput(&amp;pad, PLAYSTATION_BUTTON_SQUARE)){ // do something... } // example: checking for axis input if(SDL::getAxisInput(&amp;pad, XBOX_RIGHT_TRIGGER) &gt; 0.0f){ // do something... }
}
DUE NOTE: the input macros are built around modern and commercial controllers like Playstation, Xbox, and Nintendo however controllers with additional buttons or features aren't fully supported, however do refer to SDL or GLFW documentation on how to do so as the engine does expose the SDL and GLFW libraries.Here are all the input modules separated by library:GLFW:<br>
<a data-href="GLFW Gamepad" href="engine/input/src/glfw-gamepad.html" class="internal-link" target="_self" rel="noopener nofollow">GLFW Gamepad</a><br>
<a data-href="GLFW keyboard" href="engine/input/src/glfw-keyboard.html" class="internal-link" target="_self" rel="noopener nofollow">GLFW keyboard</a><br>
<a data-href="GLFW Mouse" href="engine/input/src/glfw-mouse.html" class="internal-link" target="_self" rel="noopener nofollow">GLFW Mouse</a>SDL:<br>
<a data-href="SDL Gamepad" href="engine/input/src/sdl-gamepad.html" class="internal-link" target="_self" rel="noopener nofollow">SDL Gamepad</a><br>
<a data-href="SDL keyboard" href="engine/input/src/sdl-keyboard.html" class="internal-link" target="_self" rel="noopener nofollow">SDL keyboard</a><br>
<a data-href="SDL Mouse" href="engine/input/src/sdl-mouse.html" class="internal-link" target="_self" rel="noopener nofollow">SDL Mouse</a>]]></description><link>engine/input/input.html</link><guid isPermaLink="false">Engine/Input/Input.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Shader]]></title><description><![CDATA[The Shader Class is responsible for compiling and editing variables from given source code of shader files such as vertex, fragment, and geometry that are written in GLSL. In order for this class to function it needs OpenGL to be initialized before utilizing this class.Due note upon compiling the shader, you MUST DELETE it before program exit to avoid memory leaksint main(){ // extract GLSL code from shader files // create shader object Shader shader; // compile shader code shader.compile(vertexCode, fragmentCode, geometryCode); // use shader and/or edit variables in the shader... // delete shader shader.DeleteShader(); // exit the program return 0;
}
Refer to GLSL documentation:
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_self">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a>
Header location/class name#include &lt;resourceSystems/resource_shader.hpp&gt; class Shader{
}; sets the shader as active
returns reference of the shader itself
refer to GLSL documentation on its use
void func(){ // extract GLSL code from shader files // create shader object // compile shader code // use the shader shader.Use();
} compiles the shader from given source code which are vertex, fragment, and/or geometry shader
due note that usually in 2D rendering the Geometry shader is not used so the last parameter is set to "nullptr" by default
upon compilation completion the compiled shader is set to active
the function does check for any compilation errors in the given source code
refer to GLSL documentation on shader compilation
void func(){ // extract GLSL code from shader files // create shader object // compile shader code shader.Compile(vertexCode, fragmentCode,geometryCode);
} used for deleting the compiled shader, it is highly recommended to delete all shaders before program exit as it may lead to memory leaks
this function allows for manual shader deletion
void func(){ // extract GLSL code from shader files // create shader object // compile shader code // delete the compiled shader shader.DeleteShader();
}
]]></description><link>engine/resourcesystems/src/shader.html</link><guid isPermaLink="false">Engine/ResourceSystems/src/Shader.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Shader Manager]]></title><description><![CDATA[The ShaderManager is responsible for handling and managing either loading or retrieving <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a>s from a given file location. It provides the loaded resources to be available across the runtime of the application, hence this class is a Static Singleton Class. In order for this class to function it needs OpenGL to be initialized before utilizing this class.Refer to OpenGL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Refer to GLSL documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_self">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a>
To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included.<br>For example: including a Static Singleton Class like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;resourcesystems/managers/texture_manager.hpp&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as a static object with its private static variables. However, this means that the static functions can be called without having to keep manual storage of the static object.In C++ to use a static function of a Static Singleton Class can be done as follow:#include &lt;resourcesystems/managers/texture_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL TextureManager::BindTextures();
}
Within the shader manager it manages resources by having them be pointing to a given name and once set it then can be used for retrieving the desired resource. <br>For Example: Load a texture using <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> and give it a namevoid func(){ // load and generate a texture from file and give it a name TexutreManager::LoadTexture("cat.png", "Pet");
}
From the example above, we loaded a texture called "cat.png" and gave it a name of "Pet", so within the manager it generated a texture that points to the name "Pet". For Example: Retrieve the generated texture using the given namevoid func(){ // retrieve the texture index to apply to a quad int textureIndex = TextureManager::GetTextureIndex("Pet"); // utilize retrieved texture for rendering...
}
Most managers that manage resources utilize this system of storing and retrieving stuff from just using a name and due note that name is explicit meaning that "Pet" != "pet".Any resource loaded into a Static Singleton Class remains persistent until program exit, which means that resources loaded at the beginning of program initialization can be then accessed at any point in the program thereafter.// initialization function that is called at the start of the program
void init(){ // load a texture into TextureManager TextureManager::LoadTexture("textures/example.png", "example");
} ... // function used at some point in program
void func(){ // get reference of loaded texture Texture&amp; tex = TextureManager::GetTexture("example");
}
<br>For Example: <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> usage across different files// texture_getter.hpp #include &lt;resourcesystems/managers/texture_manager.hpp&gt; // declare and define function
void getTexture(){ // retrieve a texture from TextureManager TextureManager::GetTexture("example");
}
//main.cpp #include &lt;resourcesystems/managers/texture_manager.hpp&gt;
#include "texture_getter.hpp" int main(){ // load a texture into TextureManager TextureManager::LoadTexture("textures/example.png", "example"); // get the texture getTexture(); // exit program return 0;
}
Obviously, due note that retrieving something that is being loaded later causes an error as what's being retrieved doesn't exist yet at the point where its being calledFor example: Retrieve and then load a texturevoid func(){ // retrieve a texture from TextureManager TextureManager::GetTexture("example"); //!ERROR: "example" doesn't exist // load a texture into TextureManager TextureManager::LoadTexture("textures/example.png", "example"); // from this point and onwards "example" exists
}
Header location/namespace/class name#include &lt;resourcesystems/managers/shader_manager.hpp&gt; class ShaderManager{
...
}; loads (and generates) a shader program from file along with a name, loads the files in this order of vertex, fragment (and geometry) and extracts the shader's source code
returns a reference of the loaded/generated shader for external use
it is optional to load a geometry shader file, if there is no geometry shader then set as nullptr
void func(){ // load a shader ShaderManager::LoadShader("quad.vert","quad.frag", nullptr, "shader");
} used to retrieve a stored shader
void func(){ // load a shader // get the shader Shader&amp; shader = ShaderManager::GetShader("quad");
}
]]></description><link>engine/resourcesystems/src/shader-manager.html</link><guid isPermaLink="false">Engine/ResourceSystems/src/Shader Manager.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Texture]]></title><description><![CDATA[The Texture class is responsible for generating and keeping track of a OpenGL texture given image data from a file. In order for this class to function it needs OpenGL to be initialized before utilizing this class.Note that by default:
Internal and Image format are set -&gt; GL_RGB
Wrapping mode on both S and T axis -&gt; GL_REPEAT
Filter Max and Min -&gt; GL_NEAREST Due note that upon generating a texture, you MUST DELETE it before program exit to avoid memory leaksint main(){ // get image data from file // create texture object Texture tex; // generate texture from image data tex.Generate(width, height, data); // Use the texture... // delete the generated texture tex.DeleteTexture(); // exit the program return 0;
}
Refer to OpenGL documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Header location/class name#include &lt;resourceSystems/resource_texture.hpp&gt; class Texture{
}; used for generating a texture given from the size and data of a image file
due note that any change to the texture format, filter, or wrap must be done before, if not you'll have to delete the texture and regenerate the texture to apply the changes
void func(){ // retrieve image data from file // create Texture object Texture tex; // generate the texture using the image data tex.Generate(imageWidth, imageHeight, imageData); // use the texture...
} used for binding the texture before rendering
<br>this function is to allow support for legacy OpenGL as the modules within the Engine don't necessarily utilize the texture ID but the texture ID index generated through the <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> and seek info about how the texture ID index is used in <a data-href="Usage" href="usage/usage.html" class="internal-link" target="_self" rel="noopener nofollow">Usage</a>
void func(){ // retrieve image data from file // create Texture object // generate texture using image data // bind the texture tex.BindTexture(); // render with the binded texture...
} used for deleting the generated texture, it is highly recommended to delete all textures before program exit as it may lead to memory leaks
this function is to allow for manual texture deletion
void func(){ // retrieve image data from file // create Texture object // generate texture using image data // delete texture before program deletion tex.DeleteTexture();
} used to set the internal format of the texture
refer to OpenGL documentation for which formats can be applied
void func(){ // retrieve image data from file // create Texture object // set texture internal format tex.SetTextureInternalFormat(GL_RGB);
} used to set the image format of the texture
refer to OpenGL documentation for which formats can be applied
void func(){ // retrieve image data from file // create Texture object // set texture image format tex.SetTextureImageFormat(GL_RGB);
} used to set the minimum filter mode of the texture
refer to OpenGL documentation for which filter can be applied
void func(){ // retrieve image data from file // create Texture object // set texture minimum filter mode tex.SetTextureFilterMin(GL_LINEAR);
} used to set the maximum filter mode of the texture
refer to OpenGL documentation for which filter can be applied
void func(){ // retrieve image data from file // create Texture object // set texture max filter mode tex.SetTextureFilterMin(GL_NEAREST);
} used to set the wrap mode on the S axis of the texture
refer to OpenGL documentation for which mode can be applied
void func(){ // retrieve image data from file // create Texture object // set texture wrap mode tex.SetWrapS(GL_REPEAT);
} used to set the wrap mode on the T axis of the texture
refer to OpenGL documentation for which mode can be applied
void func(){ // retrieve image data from file // create Texture object // set texture wrap mode tex.SetWrapT(GL_REPEAT);
} used to retrieve a reference to the ID of the texture
refer to OpenGL documentation for how to use the ID
void func(){ // retrieve image data from file // create Texture object // generate texture // get reference to the texture ID unsigned int&amp; ID = tex.GetID();
} used to retrieve the pixel width of the texture
void func(){ // retrieve image data from file // create Texture object // generate texture // get width of the texture unsigned int width = tex.GetWidth();
} used to retrieve the pixel height of the texture
void func(){ // retrieve image data from file // create Texture object // generate texture // get height of the texture unsigned int width = tex.GetHeight();
}
]]></description><link>engine/resourcesystems/src/texture.html</link><guid isPermaLink="false">Engine/ResourceSystems/src/Texture.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Texture Manager]]></title><description><![CDATA[The Texture Manager is responsible for handling and managing either loading or retrieving <a data-href="Texture" href="engine/resourcesystems/src/texture.html" class="internal-link" target="_self" rel="noopener nofollow">Texture</a>s, SubTextures, and Fonts from a given file location. It provides the loaded resources to be available across the runtime of the application, hence this class is a Static Singleton Class. In order for this class to function it needs OpenGL to be initialized before utilizing this class.Refer to OpenGL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Refer to GLSL documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_self">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a>
To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included.<br>For example: including a Static Singleton Class like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;resourcesystems/managers/texture_manager.hpp&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as a static object with its private static variables. However, this means that the static functions can be called without having to keep manual storage of the static object.In C++ to use a static function of a Static Singleton Class can be done as follow:#include &lt;resourcesystems/managers/texture_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL TextureManager::BindTextures();
}
Within the texture manager it manages resources by having them be pointing to a given name and once set it then can be used for retrieving the desired resource. For Example: Load a texture and give it a namevoid func(){ // load and generate a texture from file and give it a name TexutreManager::LoadTexture("cat.png", "Pet");
}
From the example above, we loaded a texture called "cat.png" and gave it a name of "Pet", so within the manager it generated a texture that points to the name "Pet". For Example: Retrieve the generated texture using the given namevoid func(){ // retrieve the texture index to apply to a quad int textureIndex = TextureManager::GetTextureIndex("Pet"); // utilize retrieved texture for rendering...
}
Most managers that manage resources utilize this system of storing and retrieving stuff from just using a name and due note that name is explicit meaning that "Pet" != "pet".Any resource loaded into a Static Singleton Class remains persistent until program exit, which means that resources loaded at the beginning of program initialization can be then accessed at any point in the program thereafter.// initialization function that is called at the start of the program
void init(){ // load a texture into TextureManager TextureManager::LoadTexture("textures/example.png", "example");
} ... // function used at some point in program
void func(){ // get reference of loaded texture Texture&amp; tex = TextureManager::GetTexture("example");
}
For Example: Texture Manager usage across different files// texture_getter.hpp #include &lt;resourcesystems/managers/texture_manager.hpp&gt; // declare and define function
void getTexture(){ // retrieve a texture from TextureManager TextureManager::GetTexture("example");
}
//main.cpp #include &lt;resourcesystems/managers/texture_manager.hpp&gt;
#include "texture_getter.hpp" int main(){ // load a texture into TextureManager TextureManager::LoadTexture("textures/example.png", "example"); // get the texture getTexture(); // exit program return 0;
}
Obviously, due note that retrieving something that is being loaded later causes an error as what's being retrieved doesn't exist yet at the point where its being calledFor example: Retrieve and then load a texture of the same namevoid func(){ // retrieve a texture from TextureManager TextureManager::GetTexture("example"); //!ERROR: "example" doesn't exist // load a texture into TextureManager TextureManager::LoadTexture("textures/example.png", "example"); // from this point and onwards "example" exists
}
Header location/namespace/class name#include &lt;resourcesystems/managers/texture_manager.hpp&gt; class TextureManager{
...
}; loads (and generates) a texture from file along with a name and optional texture filter option
returns a reference of the loaded/generated texture for external use
automatically the given file extension that is given, the function determines if it uses alpha or not
by default the texture's filter is set to be nearest and it is optional to set it to true which sets to be linear
void func(){ // load a texture TextureManager::LoadTexture("textures/example.png", "example");
} loads (and generates) a font texture from file with a specified resolution of the font texture (width and height) and font size along with name and optional texture filter option
returns a reference of the set of font characters for external use
by default the texture's filter is set to be nearest and it is optional to set it to true which sets to be linear
void func(){ // load a font texture TextureManager::LoadFontTexture("fonts/arial.ttf","font", 512, 512, 24.0f);
} use a loaded texture to create a sub texture along with a name
you must know the dimensions of the texture
use the coordinates that start from the bottom left of the texture, the cell size or the portion taken from the coordinate, and by default per pixel is set to 1 which optional can be changed
void func(){ // load a texture // create a subtexture TextureManager::GenerateSubTexture("bench", benchesTexture, {0.0f, 5.0f}, 20.0f, 20.0f);
} create a white texture that is named "default"
this is useful for debugging, placeholder, and/or useful texture without having to create a similar texture by hand.
when called again does nothing
void func(){ // generate white texture TextureManager::GenerateWhiteTexture(); // get the generated texture Texture&amp; tex = TextureManager::GetTexture("default");
} retrieves the texture index from a stored texture
the index of textures are binded through QuadManager's BindTexture()
<br>useful to <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a>
void func(){ // load texture // get the texture index from stored texture int texIndex = TextureManager::GetTextureIndex("default"); // example: use the texture index to render a quad with the loaded texture // ... QuadRenderer::DrawQuad(texIndex, position, size, rotation, color); // ...
} used to retrieve a stored texture
void func(){ // load a texture // get the loaded texture Texture&amp; tex = TextureManager::GetTexture("default");
} used to retrieve a stored font texture map that contains characters and associated font character
void func(){ // load a font // get the font texture CharacterSet&amp; font = TextureManager::GetFontTexture("font");
} used to retrieve a generated sub texture
void func(){ // load a texture Texture&amp; tex = TextureManager::LoadTexture("animals.png","animals"); // generate a sub texture from the loaded texture TextureManager::GenerateSubTexture("animals", tex, {2.0f, 0.0f}, {5.0f,5.0f}); // get the sub texture std::array&lt;glm::vec2, 4&gt;&amp; texCoords = TextureManager::GetSubTexture("cat");
} <br>used to bind all texture (not fonts) from the texture list to be used by OpenGL so then it can be used by a renderer like <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a>
is automatically called by LoadTexture()
can be called multiple times
void func(){ // load a texture // bind all loaded textures, note that LoadTexture already calls this func TextureManager::BindTextures();
}
]]></description><link>engine/resourcesystems/src/texture-manager.html</link><guid isPermaLink="false">Engine/ResourceSystems/src/Texture Manager.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Resource Systems]]></title><description><![CDATA[The Resource Systems are responsible for making it easy to load, manage, and retrieve resources that are important to a graphical application.Due note that those that are tagged with "Requires OpenGL" means that OpenGL needs be initialized before usage and to satisfy this using the engine is through <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>int main(){ // create App window class that inherits from Window AppWindow app; // initialize window app.initializeWindow(800, 600, "My App"); // At this point Resource system that require OpenGL are satisfied...
}
<br>Within Resource Systems there are managers that well... manage resources and types that are specific to a graphical application or program. Before heading into learning what each manager or type does, you should know how to utilize Static Singleton Classes which you can find here <a data-href="3 Sisters-Framework-Engine" href="engine/3-sisters-framework-engine.html" class="internal-link" target="_self" rel="noopener nofollow">3 Sisters-Framework-Engine</a> as any manager that manages any kind of resource is typically a Static Singleton Class unless stated otherwise.<br><a data-href="Texture" href="engine/resourcesystems/src/texture.html" class="internal-link" target="_self" rel="noopener nofollow">Texture</a> - (Requires OpenGL) handles generating a texture given data that is extracted from an image file<br>
<a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> - (Requires OpenGL) handles compiling shader code given from shader files such as a vertex, fragment, or geometry shader. It also contains functions to change values of the given shaderThese resource types are Classes that handle doing the calculation, generating, or modifying either texture or shader usable to OpenGL. This type contains the texture coordinates of all particular characters from a loaded font which can be used for rendering text This type contains the texture coordinates of a texture <br>These resource types extensions mean that they extend the use of a certain resource type and the ones shown extend from <a data-href="Texture" href="engine/resourcesystems/src/texture.html" class="internal-link" target="_self" rel="noopener nofollow">Texture</a> indirectly as they require just the texture ID that is generated.<br><a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> - (Requires OpenGL) handles <a data-href="Texture" href="engine/resourcesystems/src/texture.html" class="internal-link" target="_self" rel="noopener nofollow">Texture</a>, Font, and SubTexture loading and retrieving<br>
<a data-href="Shader Manager" href="engine/resourcesystems/src/shader-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Shader Manager</a> - (Requires OpenGL) handles <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> loading and retrievingWithin these managers they manage resources by having them be pointing to a given name and once set it then can be used for retrieving the desired resource. void func(){ // load and generate a texture from file and give it a name TextureManager::LoadTexture("cat.png", "Pet");
}
From the example above, we loaded a texture called "cat.png" and gave it a name of "Pet", so within the manager it generated a texture that points to the name "Pet". Now to retrieve the generated texturevoid func(){ // retrieve the texture index to apply to a quad int textureIndex = TextureManager::GetTextureIndex("Pet"); // utilize retrieved texture for rendering...
}
Most managers that manage resources utilize this system of storing and retrieving stuff from just using a name and due note that name is explicit meaning that "Pet" != "pet".When compiling your application into an executable program and upon opening you are given an error that the program can't find a file, as an example we'll use a texture file called "cat.png", and the program gives an error. This is because the program wasn't either given a path to the file and/or the file is not within reach of the executable. To properly set this up or fix the issue follow the following:In the directory of where the application was compiled to should look likes this:/build /shaders /textures cat.png myapp.exe
In the example above, the executable is within a "build" folder and along side with two other folders "shaders" and "textures". Within the "textures" folder is the texture the program is trying to load is called "cat.png".In the code of the program the line that's giving the errorTextureManager::LoadTexture("cat.png","cat");
/build /shaders /textures cat.png myapp.exe
Now the program now properly executes, but by organization of the files can get messy and likely to cause a headache in finding what files is missing when the program gets larger.TextureManager::LoadTexture("textures/cat.png", "cat");
Now the code properly executes and the organization of the files is much better as the program gets larger we can separate what files are "textures", "shaders", "sound files", or etc.Here are all the Resource systems for quick reference:<br>
<a data-href="Texture" href="engine/resourcesystems/src/texture.html" class="internal-link" target="_self" rel="noopener nofollow">Texture</a><br>
<a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a><br>
<a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a><br>
<a data-href="Shader Manager" href="engine/resourcesystems/src/shader-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Shader Manager</a>Other types of resource managers (these don't require OpenGL or a window context)<br>
<a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> - handles loading and retrieving sound<br>
<a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> - handles managing entities, components, and systems]]></description><link>engine/resourcesystems/resource-systems.html</link><guid isPermaLink="false">Engine/ResourceSystems/Resource Systems.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Sound Manager]]></title><description><![CDATA[The Sound Manager is responsible for handling and managing in setting up audio device, loading sound files, and managing sound sources. It also provides sound buffers (loaded sound files) and sound sources to be access at anytime across the runtime of the application. It is required to have first an audio device setup before doing anything else through OpenAL.Refer to OpenAL documentation:
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.openal.org/documentation/OpenAL_Programmers_Guide.pdf" target="_self">https://www.openal.org/documentation/OpenAL_Programmers_Guide.pdf</a>
To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included.<br>For example: including a Static Singleton Class like <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>#include &lt;soundSystems/managers/sound_manager.hpp&gt;
<br>From this point the class <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> calls its private constructor which only initializes as a static object with its private static variables. However, this means that the static functions can be called without having to keep manual storage of the static object.In C++ to use a static function of a Static Singleton Class can be done as follow:#include &lt;soundSystems/managers/sound_manager.hpp&gt; void func(){ // retrieve a loaded sound buffer with the name "jump_sound" SoundBuffer buf = SoundManager::GetSound("jump_sound");
}
<br>By simply calling the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>'s "InitDevice" function it will both initialize OpenAL and setup by default a sound device that your operating system set as being the "default" or "primary"void func(){ // initialize OpenAL and default OS sound device SoundManager::InitDevice();
}
<br>It's also possible to select a different sound device before initializing, which is possible to make UI for selecting a sound device. This is done by calling the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>'s "GetAllSoundDevices" function to get a current list of connected sound devices.void func(){ // get list of current sound devices std::vector&lt;std::string&gt; devices = SoundManager::GetAllSoundDevices(); //? Do some logic and IU to let user select their sound device // initialize OpenAL and preferred sound device SoundManager::InitDevice(devices[selectedDevice]);
}
<br>From this point you can load sound files, Must be in WAV format, and due note that sounds are loaded within the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>. When loading a file, it can be given a name for easy retrieval. Also note that sounds are loaded as "SoundBuffers"void func(){ // load a sound SoundManager::LoadSound("music", "sounds/music.wav");
}
Using the name given in the example above being "music", it returns an ID of that sound to which OpenAL uses to play that loaded soundvoid func(){ // get sound buffer unsigned int musicSoundBuffer = SoundManager::GetSound("music"); // utilize obtained sound buffer to then play it...
}
Due note that you can't retrieve a resource or object that is loaded later as it needs to first exist in the very beginning of the application.void func(){ // get sound buffer called "music", ERROR: "music" doesn't exist yet unsigned int musicSoundBuffer = SoundManager::GetSound("music"); // load sound file and have it called "music" SoundManager::LoadSound("music", "sounds/music.wav"); // from this point forward, "music" can be retrieved
}
<br>Furthermore, <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> can also be created and obtained through <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>, though it's recommended to keep a reference of the sound source to avoid always doing a linear search on every frame. void func(){ // create sound source and keep a copy of it SoundSource source = SoundManager::CreateSoundSource("music_player");
}
Header location/namespace/class name#include &lt;soundSystems/managers/sound_manager.hpp&gt; class SoundManager{
...
}; Initializes OpenAL and a given audio device by their explicit name
By default the OS default selected device is used
NOTE: It is important to call thins function before calling another function
void func(){ // initialize OpenAL and setup default audio device SoundManager::InitDevice();
} Returns a list of all sound devices connected to the system
Optional debug printing of the queried device names. It is disabled by default
void func(){ // get list of all sound devices std::vector&lt;std::string&gt; devices = SoundManager::GetAllSoundDevices(); // Example: Do some logic to let user pick out their audio device // initialize OpenAL and setup user specified audio device SoundManager::InitDevice(devices.at(userSelection)); } Use to retrieve a loaded sound buffer ID by name
void func(){ // retrieve loaded sound buffer called "music" SoundBuffer buf = SoundManager::GetSound("music");
} <br>Used to retrieve a existing <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> by name
void func(){ // retrieve a existing sound source called "music_player" SoundSource&amp; source = SoundManager::GetSoundSource("music_player");
} Used to load a sound file to be turned into a buffer with an attached name
NOTE: sound files must be in WAV format
void func(){ // load sound file and have it called "music" SoundManager::LoadSound("music", "sounds/music.wav"); // get sound buffer called "music", since it's been loaded prior unsigned int musicSoundBuffer = SoundManager::GetSound("music");
} <br>Creates a <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> with an attached name for retrieval
Optional: A sound buffer can be given
void func(){ // create a sound source called "player" and give valid sound buffer SoundManager::CreateSoundSource("player", soundBuf); // create a sound source called "music_player" and keep a local reference SoundSource source = SoundManager::CreateSoundSource("music_player");
}
]]></description><link>engine/sound/src/sound-manager.html</link><guid isPermaLink="false">Engine/Sound/src/Sound Manager.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Sound Source]]></title><description><![CDATA[The Sound Source is responsible for playing a given sound buffer (ei a loaded sound file by <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>). The modifiable properties when playing a sound can be gain, pitch, and position in 3D space. It is required to have first an audio device setup before doing anything else through OpenAL.Refer to OpenAL documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.openal.org/documentation/OpenAL_Programmers_Guide.pd" target="_self">https://www.openal.org/documentation/OpenAL_Programmers_Guide.pd</a>
<br>Before utilizing <a data-href="SoundSource" href=".html" class="internal-link" target="_self" rel="noopener nofollow">SoundSource</a> ensure to initialized <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> by simply calling the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>'s "InitDevice" function it will both initialize OpenAL and setup by default a sound device that your operating system set as being the "default" or "primary"void func(){ // initialize OpenAL and default OS sound device SoundManager::InitDevice();
}
<br> Further details on initializing can be found in the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a><br>It recommended to create <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> objects through <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>. However, you can create sources separately though YOU MUST handle OpenAL cleanup yourself. You must call to "generateSource" function in order to utilize any other function in <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a>void func(){ // creating an empty sound source obj SoundSource source; // generate sound source source.generateSource(); // OpenAL destroy sound source alDeleteSources(1, &amp;source.getSource());
}
<br>Before playing a loaded sound buffer, due note that they can be loaded through <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>. <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> is flexible when it comes to playing a desired sound, so there are multiple different methods.Due note a single sound source can only play ONE sound at a time<br>For the following examples assume that you have a loaded sound through <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> and only creating <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> by hand rather than using <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>.It doesn't matter when the "play" function is being called multiple times as it just continues playing until it is done. Method 1: Giving a sound buffer after creation and playing soundvoid func(){ //? Assume loaded sound buffer has name of "music" // creating an empty sound source obj SoundSource source; // generate sound source source.generateSource(); // setting the sound buffer source.setBuffer(SoundManager::GetSound("music")); // playing prior loaded sound buffer called "music" source.play(); // OpenAL destroy sound source alDeleteSources(1, &amp;source.getSource());
}
Method 2: Giving sound buffer when playing, due note this replaces the current loaded sound buffervoid func(){ //? Assume loaded sound buffer has name of "music" // creating an empty sound source obj SoundSource source; // generate sound source source.generateSource(); // giving a sound buffer and then playing it source.play(SoundManager::GetSound("music")); // OpenAL destroy sound source alDeleteSources(1, &amp;source.getSource());
}
To stop playing sound utilize the "stop" functionvoid func(){ //? Assume loaded sound buffer has name of "music" // creating an empty sound source obj SoundSource source; // generate sound source source.generateSource(); // giving a sound buffer and then playing it source.play(SoundManager::GetSound("music")); // stopping sound being played source.stop(); // OpenAL destroy sound source alDeleteSources(1, &amp;source.getSource());
}
Header location/namespace/class name#include &lt;soundSystems/sound_source.hpp&gt; class SoundSource{
...
}; Used to create a OpenAL instance of a sound source
Returns OpenAL source ID
<br><a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> typically handles create sound sources
Note: you must handle source deletion yourself
void func(){ // creating an empty sound source obj SoundSource source; // generate sound source and keep a reference unsigned int&amp; id = source.generateSource(); // OpenAL destroy sound source by o alDeleteSources(1, &amp;id));
} Used to change the pitch of the sound to be played
By default pitch is set to 1.0f
Given range must be within 0.0f to 1.0f
void func(){ //? Assume sound source is already created // change the pitch of the sound source.setPitch(0.8f); // play sound...
} Used to change the gain or loudness of the sound to be played
By default gain is set to 1.0f (which is max volume)
Given range must be within 0.0f to 1.0f
void func(){ //? Assume sound source is already created // change the gain of the sound source.setGain(0.8f);* // play sound...
} Used to set the position of the source in 3D space
By default source sits at center, or in other words sits right in front of the camera
void func(){ //? Assume sound source is already created // change the position of the sound above source.setPosition3D(glm::vec3(0.0f, 1.0f, 0.0f)); // play sound...
} Used to set the position of the source in 2D space
By default source sits at center, or in other words sits right in front of the camera
void func(){ //? Assume sound source is already created // change the position of the sound above source.setPosition2D(glm::vec2(0.0f, 1.0f)); // play sound...
} Adds and sets the sound buffer of the sound source
<br>Sound buffer can be obtained from <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>
void func(){ //? Assume sound source is already created // set the sound buffer source.setBuffer(buffer); // play sound...
} sets the "loop sound" parameter to make the sound being played automatically be looped without having to call the "play" function again
void func(){ //? Assume sound source is already created // set sound to loop source.setLoopSound(true); // play sound...
} Used to retrieve current buffer loaded into the sound source
void func(){ //? Assume sound source is already created // get sound buffer unsigned int buf = source.getBuffer();
} Returns reference of the OpenAL sound source ID
void func(){ //? Assume sound source is already created // set sound to loop unsigned int&amp; src = source.getSource(); // OpenAL destroy sound source alDeleteSources(1, &amp;src;
} Used to play a sound
Optional: "playAgainWhenFinished" means to wait for sound to finish to then play again
void func(){ //? Assume sound source is already created // play sound with "playAgainWhenFinished" being set source.play(true);
} void func(){ //? Assume sound source is already created // set sound buffer and play sound with "playAgainWhenFinished" being set source.play(buffer, true);
} Used to stop current sound
void func(){ //? Assume sound source is already created // play sound with "playAgainWhenFinished" being set source.play(true); // stop sound source.stop();
} Stops current sound and restarts the sound to the beggining
void func(){ //? Assume sound source is already created // play sound with "playAgainWhenFinished" being set source.play(true); // pause and restart sound source.restartSound(); // play again from the beggining source.play);
}
]]></description><link>engine/sound/src/sound-source.html</link><guid isPermaLink="false">Engine/Sound/src/Sound Source.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Sound]]></title><description><![CDATA[The Sound is responsible for allowing to load and play audio as well as allowing to manipulate the loaded sound to be louder, have a different pitch, and/or sound like its positioned somewhere in space. The engine utilizes currently OpenAL or OpenAL-Soft back-end that allows for playing sound. Refer to OpenAL documentation:
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.openal.org/documentation/OpenAL_Programmers_Guide.pdf" target="_self">https://www.openal.org/documentation/OpenAL_Programmers_Guide.pdf</a>
<br>The sound systems use a combination of a Static Singleton, <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>, and objects <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> To include a Static Singleton module in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included.<br>For example: including a Static Singleton module like <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>#include &lt;soundSystems/managers/source_manager.hpp&gt;
<br>From this point the class <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> calls its private constructor which only initializes as static object with its private static variables.In C++ to use a function of a Static Singleton class can be done as follow:#include &lt;soundSystems/managers/source_manager.hpp&gt; void func(){ // get a sound source // StaticClassName::Function() SoundSource source = SoundManager::GetSoundSource("player");
}
However, some of the Static Singleton Classes require more information to be fully used anywhere else so some may need to be used in sequence.<br>To get started, the first thing is to setup the hardware of where the sound will play through, like your speakers, headphones, and etc, which can be done through <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>. <br>By simply calling the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>'s "InitDevice" function it will both initialize OpenAL and setup by default a sound device that your operating system set as being the "default" or "primary"void func(){ // initialize OpenAL and default OS sound device SoundManager::InitDevice();
}
<br>It's also possible to select a different sound device before initializing, which is possible to make UI for selecting a sound device. This is done by calling the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>'s "GetAllSoundDevices" function to get a current list of connected sound devices.void func(){ // get list of current sound devices std::vector&lt;std::string&gt; devices = SoundManager::GetAllSoundDevices(); //? Do some logic and IU to let user select their sound device // initialize OpenAL and preferred sound device SoundManager::InitDevice(devices[selectedDevice]);
}
<br>From this point you can load sound files, Must be in WAV format, and due note that sounds are loaded within the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>. When loading a file, it can be given a name for easy retrieval. Also note that sounds are loaded as "SoundBuffers"void func(){ // load a sound SoundManager::LoadSound("music", "sounds/music.wav");
}
Using the name given in the example above being "music", it returns an ID of that sound to which OpenAL uses to play that loaded soundvoid func(){ // get sound buffer unsigned int musicSoundBuffer = SoundManager::GetSound("music"); // utilize obtained sound buffer to then play it...
}
<br>Furthermore, <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> can also be created and obtained through <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>, though it's recommended to keep a reference of the sound source to avoid always doing a linear search on every frame. void func(){ // create sound source and keep a copy of it SoundSource source = SoundManager::CreateSoundSource("music_player");
}
<br>You can also modify the sound source that is inside of the <a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> by either keeping a reference or calling functions directlyvoid func(){ // modify pitch of sound source directly SoundManager::GetSoundSource("music_player").setPitch(0.4f); // Alternatively, modify pitch by keeping a reference SoundSource&amp; source = SoundManager::GetSoundSource("music_player"); source.setPitch(0.5f);
}
<br>To play sounds with a <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> you must give it a "SoundBuffer" to play as well you can change the sound buffer later in your applicationvoid func(){ // give sound source a sound buffer upon creation SoundManager::CreateSoundSource("music_player", musicSoundBuffer); // change sound source sound buffer SoundSource&amp; source = SoundManager::GetSoundSource("music_player"); source.setBuffer(newMusicSoundBuffer); // Alternatively, changing the sound buffer directly SoundManager::GetSoundSource("music_player").setBuffer(newMusicSoundBuffer);
}
<br>To play a sound from a sound buffer, simply call it from the <a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a>void func(){ // play sound from a sound source SoundSource&amp; source = SoundManager::GetSoundSource("music_player"); source.play(); // play sound from a sound source directly SoundManager::GetSoundSource("music_player").play();
}
The sound modules are separated parts that make the sound system of the engine:
<br><a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a> - keeps track of loaded sounds, sound sources, and can initialize OpenAL to allow for playing audio and can ONLY opens default sound device
<br><a data-href="Sound Source" href="engine/sound/src/sound-source.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Source</a> - allows for playing a given sound buffer, can change how the audio is played (EX: different pitch or gain)
]]></description><link>engine/sound/sound.html</link><guid isPermaLink="false">Engine/Sound/Sound.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Window]]></title><description><![CDATA[The Window is responsible for creating a OpenGL context window which allows for direct/indirect functionality of other components within the engine such as the <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a>. The Window class is an abstract class meaning YOU HAVE TO inherit this class which means creating a class that inherits from Window in order to make use of it.For example AppWindow class inherits from Window// app_window.hpp
// recommend to place classes in headers and define functions in source // since both GLFW and SDL versions the Window class is named the same way
// to differentiate use of namespace is required
// example: use the GLFW window version using namespace GLFW; class AppWindow : public Window{ private: public: // constructor AppWindow();
};
Inside the class there are functions that are required to be overridden which then allows for specifying your own code to make the app do something and those functions or paradigm pattern is:
**init()
**stepUpdate(double)
**update()
**render(double)
*these functions or paradigm are the same for both GLFW and SDL versions of window*So it should look like this:Header// app_window.hpp class AppWindow : public Window{ private: public: // constructor AppWindow(); // override window functions void init() override; void stepUpdate(double ts) override; void update() override; void render(double ts) override; };
Source#include "app_window.hpp" // define constructor, also call Window constructor
AppWindow::AppWindow() : Window(){ } // define window functions void AppWindow::init(){ // initialize resources, players, or systems
} void AppWindow::stepUpdate(double ts){ // fixed update
} void AppWindow::update(){ // update
} void AppWindow::render(double ts){ // render cool stuff }
Since the window class is the basis for engine, in order to start using it we need understand the following functions: This function initializes the window and OpenGL capabilities. For parameters the function requires width and height of the window being created. Optionally you can give the window a name. This function first calls the function init() and then updates the following functions in a infinite loop until given a close window call init()
stepUpdate(double)
update()
render(double) To put it all together in a main function#include "app_window.hpp" int main(){ // initialize class obj AppWindow app; // initialize the window with a size of 800x600 with the name "My App" app.initializeWindow(800, 600, "My App"); // call runtime app.runtime(); return 0;
}
Now when compiling and executing the executable it should give you a black screen window. Here are the currently different libraries that handle windowing with OpenGL capabilities, there are some minor differences between them, but most functions are relatively the same as well with their naming as well:
<br>**<a data-href="Window-GLFW" href="engine/window/src/window-glfw.html" class="internal-link" target="_self" rel="noopener nofollow">Window-GLFW</a>
<br>**<a data-href="Window-SDL" href="engine/window/src/window-sdl.html" class="internal-link" target="_self" rel="noopener nofollow">Window-SDL</a> ]]></description><link>engine/window/window.html</link><guid isPermaLink="false">Engine/Window/Window.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Orthographic Camera]]></title><description><![CDATA[The Camera classes are responsible for calculating an orthographic projection onto the screen to allow for 2D rendering. Refer to <a data-href="Resource Systems" href="engine/resourcesystems/resource-systems.html" class="internal-link" target="_self" rel="noopener nofollow">Resource Systems</a> <br><a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a>
Refer to GLM documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://glm.g-truc.net/0.9.9/api/modules.html" target="_self">http://glm.g-truc.net/0.9.9/api/modules.html</a>
Header location/class name:#include &lt;cameras/ortho_camera.hpp&gt; class OrthoCamera{
...
}; used to refer to the camera's position <br>Refer to GLM documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="http://glm.g-truc.net/0.9.9/api/modules.html" target="_self">http://glm.g-truc.net/0.9.9/api/modules.html</a>
void func(){ // example: change camera position // move camera to the left camera.position.x += 1.0f; // move camera down camera.position.y -= 7.5f; // set camera to a specific position camera.position = glm::vec2(-5.0f, 1.0f);
} used to set both the width and height of the camera's view
void func(){ // example: set camera dimensions camera.setDimensions(1280, 720);
} used to set the width of the camera's view
void func(){ // example: set camera width camera.setWidth(1920);
} used to set the height of the camera's view
void func(){ // example: set camera height camera.setHeight(1080);
} used to retrieve the width of the camera's view
void func(){ // example: get the camera width unsigned int width = camera.getWidth();
} used to retrieve the height of the camera's view
void func(){ // example: get the camera height unsigned int height = camera.getHeight();
} <br>does calculations of the view and projection to create the ProjectionView and set to given <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a>
<br>The vertex <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> must contain this variable:
uniform mat4 projectionView; <br>it allow for updating the <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a>'s projectionView variable
can be overwritten void func(){ // example: calculate the projection view // load a shader... // calculate the projection view camera.calculateProjectionView(shader);
} ```
]]></description><link>engine/cameras/src/orthographic-camera.html</link><guid isPermaLink="false">Engine/Cameras/src/Orthographic Camera.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Camera]]></title><description><![CDATA[The Camera modules are responsible for calculating projection onto the screen.
These classes are objects and they keep track of their own position in world space.Before using this class YOU MUST have a loaded shader and in that shader it must have the following variable called:uniform mat4 projectionView;
fortunately, the default shaders that the engine comes with does contain this "projectionView" Refer to <a data-href="Resource Systems" href="engine/resourcesystems/resource-systems.html" class="internal-link" target="_self" rel="noopener nofollow">Resource Systems</a> on how to get a shader loadedThe functions and variables that are common between them **position this variable editable variable refers to the camera's position
depending on the type of camera it's either a glm::vec2 or glm::vec3<br>
refer to GLM documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="http://glm.g-truc.net/0.9.9/api/modules.html" target="_self">http://glm.g-truc.net/0.9.9/api/modules.html</a> <br>**calculateProjectionView(<a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a>) does calculations of the view and projection to create the ProjectionView and set to given shader
in the calculation it includes the position of the camera
can be overwritten using inheritance When going through a camera's "initialization" it also sets the world position where any created transform originates from which by default is the bottom left corner of the screen (can be changed by overwriting the calculateProjectionView()).Also note that when changing the position or rotation of the camera, you must call calculateProjectionView() again in order for the change to take effect onto the shader so thus the change takes affect on the screen.Initialization of a cameravoid func(){ // load a shader... // create a camera object // example: using Orthographic camera OrthoCamera camera; // no change given to camera position // set dimensions on the camera camera.setDimensions(1280, 720); // calculate the projection view and apply to the shader once camera.calculateProjectionView(shader); // do something to the camera...
} Types of Camera examplesStationary cameravoid func(){ // load a shader... // create a camera object // example: using Orthographic camera OrthoCamera camera; // set dimensions on the camera camera.setDimensions(1280, 720); // calculate the projection view and apply to the shader once camera.calculateProjectionView(shader);
}
Moving cameravoid func(){ // load a shader... // create a camera object // example: using Orthographic camera OrthoCamera camera; // set dimensions on the camera camera.setDimensions(1280, 720); // calculate the projection view camera.calculateProjectionView(shader); // move the camera up camera.position.y += 2.5f; // recalculate the projection view again for the change to take effect camera.calculateProjectionView(shader);
}
Here are the different types of cameras that handle what type of projection that is needed. For 2D projection:<br>
<a data-href="Orthographic Camera" href="engine/cameras/src/orthographic-camera.html" class="internal-link" target="_self" rel="noopener nofollow">Orthographic Camera</a>]]></description><link>engine/cameras/camera.html</link><guid isPermaLink="false">Engine/Cameras/Camera.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Component]]></title><description><![CDATA[A Component is represented as a data structure that only contains data. So to create a component it would look likes this:// example of component with data
struct Component{ int value; float timer;
};
These components can be attached to an entity or numerous entities. Each entity can have the same component but they'll have a different instance of that same component, meaning similar components attached to different entities don't affect each other when a change only happens to one component or entity.Within the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> when registering each component also create a "ComponentType" which is just a single bit turned within a 32 bit set. This then allows for signatures that can be then used to filter entities with various components to then find entities with a specific set of signatures, or component types in simpler terms, which is what the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>s.<br>Within the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> there's a limit to how many components there can be which is 32 total components that can be registered and used. <br>The following are <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> functions that concern <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> directlyHeader location/class name:#include &lt;ecs/ecs.hpp&gt; class ECS{
...
}; <br>used to register a specified <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> for <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a> and <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> usage
due note that without registering a component, you can't add such component to an entity or create signatures for systems
// define a component
// EX: test component called 'Position' contains a float variables
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component ECS::RegisterComponent&lt;Position&gt;(); // add component to an entity or create signature for system...
} <br>used to add a specified <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> to an existing entity
due note that the specified component must be registered beforehand in order for it work
When adding components to an entity, you can add multiple components at the same time and you can initialize the values of the components all within the same line of code
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Texture{ int ID;
}; void func(){ // initialize ECS // register component 'Position' // create entity // add component to entity ECS::AddComponent(entity, Position{});
} // *Alternative*
void func(){ // initialize ECS // register component 'Position' // create entity // add component to entity, and initalize values ECS::AddComponent(entity, Position{ .x = 10, .y = 20 });
} // *Alternative*
void func(){ // initialize ECS // register components // create entity // add multiple component to entity, and initalize values ECS::AddComponent(entity, Position{ .x = 10, .y = 20 }, Texture{ .ID = 3 });
} <br>used to remove a <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> from an existing entity
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // create entity // add component to entity // remove component from entity ECS::RemoveComponent&lt;Position&gt;(entity);
} <br>used to get reference of an existing entity's <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>
if the component is not registered then it will return an error
if the entity doesn't have such component then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // create entity // add component to entity // get entity component Position&amp; pos = ECS::GetComponent&lt;Position&gt;(entity); // modify the component pos.x += 10.0f; pos.y -= 5.0f;
} <br>used to check if the entity contains given <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // create entity // add component to entity // check if entity has component if(ECS::CheckComponent&lt;Position&gt;(entity) == true){ // entity does have component // do something... }
} <br>used to get the component type of given <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> ComponentType is a uint8_t where each bit belongs to a registered component
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // get component type from registered component ComponentType type = ECS::GetComponentType&lt;Position&gt;();
} <br>used to retrieve the signature of given <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>
ComponentType is a uint8_t where each bit belongs to a registered component, which is then stored into a signature format
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // get signature from registered component Signature sig = ECS::GetComponentSignature&lt;Position&gt;();
} used to retrieve the signature of given component types
ComponentType is a uint8_t where each bit belongs to a registered component, which is then stored into a signature format
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Material{ float r, g, b;
}; void func(){ // initialize ECS // register components // get signature from registered components Signature sig = ECS::GetMultiComponentSignature( ECS::GetComponentType&lt;Position&gt;(), ECS::GetComponentType&lt;Material&gt;() );
} used to retrieve the bit location that the given component belongs to
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Material{ float r, g, b;
}; void func(){ // initialize ECS // register component // get signature from registered components unsigned int pos_sig_bit = ECS::GetComponentSignatureBit&lt;Position&gt;(); unsigned int mat_sig_bit = ECS::GetComponentSignatureBit&lt;Material&gt;(); // The value of pos_sig_bit is 1 in decimal or ...000000000001 in binary // The value of mat_sig_bit is 2 in decimal or ...000000000010 in binary
}
]]></description><link>engine/ecs/src/component.html</link><guid isPermaLink="false">Engine/ECS/src/Component.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Entity]]></title><description><![CDATA[An Entity is represented as an ID, a number like 2 or 19, that is "linked" to an array of components like a position or texture component. This can be used to logically represent a Player, a UI element, or an Item.Entity is of type unsigned integer of 32-bit, the name "Entity" is an alias that points to that type. Thus declaring an Entity is the same as declaring said mentioned type.// with alias
Entity e;
// without the alias
std::uint32_t u; // both 'e' and 'u' are the same type
In ECS system handles giving an entity an ID, attaching components, and allow those entities with certain components (called a signature) that are used by systems.There's a limit to how many entities there can be which can be found in// location of the header
#include &lt;ecs/types/entity.hpp&gt; ...
// define the maximum amount of entites
const Entity MAX_ENTITIES = 10000;
and this is because we need to allocate how much static memory we need for each of entities to avoid having to do so during runtime.The following are <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> functions that concern <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a> directlyHeader location/class name:#include &lt;ecs/ecs.hpp&gt; class ECS{
...
}; used to create an entity, returns the value that refers to that create entity
there's a limit of how many entities can be created in total which is 10000
void func(){ // initialize ECS // create an entity Entity entity = ECS::CreateEntity(); // do something with created entity...
} used to get an existing entity's component signature
help for identifying all the components within given entity
void func(){ // initialize ECS // create an entity // add a component to entity // get signature from entity Signature sig = ECS::GetEntitySignature(entity);
} used to destroy a given entity
it also removes all components attached to that entity
avoid storing important data or pointers in components that are then stored onto the entity as it will be lost and may cause a segfault when trying to access the pointer that was on the entity
void func(){ // initialize ECS // create an entity // optional: add component to entity // destroy entity ECS::DestroyEntity(entity);
}
]]></description><link>engine/ecs/src/entity.html</link><guid isPermaLink="false">Engine/ECS/src/Entity.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[System]]></title><description><![CDATA[ System is sort of a manager that is able to access all entities that have a set of specific components that is required by the system in order to manipulate the entities.To define a system it needs to inherit from System and then you can define functions, optionally variables as well, that do something with the added entities that match a signature, or specific set of <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>s// you can include the ECS header directly #include &lt;ecs/ecs.hpp&gt; // create an example class that inherits from System
class ExampleSystem : public System{ public: // some function that does something with entities void func();
};
Once defining a system we also need a way to refer and call functions from it safely without having to deal deleting the pointer thus we need to define a alias that just refers to an instance of the system we just created// you can include the ECS header directly #include &lt;ecs/ecs.hpp&gt; // create an example class that inherits from System
class ExampleSystem : public System{ ...
}; // define alias
using ExampleSystem_Ptr = std::shared_ptr&lt;ExampleSystem&gt;;
To use the alias in C++ is similar to defining a variable// create reference of the system
ExampleSystem_Ptr ex; // to set the system, which sets the std::shared_ptr
ex = some_func(); // to call a function of the system
ex-&gt;update_entities();
<br>Then we need to register the System into <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> so it can automatically give entities to the system we created that have a specific set of <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>s using "RegisterSystem()"void func(){ // initialize ECS // register system ECS::RegisterSystem&lt;ExampleSystem&gt;();
} // alternative
void func(){ // initialize ECS // register system and get reference to the system ExampleSystem_Ptr ex = ECS::RegisterSystem&lt;ExampleSystem&gt;(); // use reference to system ex-&gt;do_something();
}
<br>To set up the system's signatures using <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> we need to have registered <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>s to then set up the signatures using "SetSystemSignature()"// example components
struct Health{ int num;
}; struct Position{ int x, y;
}; void func(){ // initialize ECS // register components // register system // create signature Signature sig; // give the signature the components sig.set(ECS::GetComponentType&lt;Health&gt;()); sig.set(ECS::GetComponentType&lt;Position&gt;()); // set the system's signatures ECS::SetSystemSignature&lt;ExampleSystem&gt;(sig);
} // alternative
void func(){ // initialize ECS // register components // register system // set the system's signatures ECS::SetSystemSignature&lt;ExampleSystem&gt;( ECS::GetComponentType&lt;Health&gt;(), ECS::GetComponentType&lt;Position&gt;() );
}
<br>Within the system we created, to grab the entities which have a matching signature that the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> gives and do something with them in a function there is a array called "entities"// define a function in the system
void ExampleSystem::func(){ // loop through all given entities from ECS for(auto const&amp; entity ; entities){ // grab reference of a entity's component // do something with the component... }
}
<br>The following are <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> functions that concern <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> directlyHeader location/class name:#include &lt;ecs/ecs.hpp&gt; class ECS{
...
}; <br>used to register a <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> and it as well returns the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> reference for external use
<br>returns nullptr if the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> is already registered
// define system
class MoveSystem : public System{
...
}; void func(){ // initialize ECS // register system ECS::RegisterSystem&lt;MoveSystem&gt;();
} // Alternative
void func(){ // initialize ECS // register system and get the system reference std::shared_ptr&lt;MoveSystem&gt; system = ECS::RegisterSystem&lt;MoveSystem&gt;();
} <br>used to get reference of a registered <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>
<br>returns nullptr if the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> hasn't been registered
// define system
class MoveSystem : public System{
...
}; void func(){ // initialize ECS // register system // get registered system std::shared_ptr&lt;MoveSystem&gt; system = ECS::GetSystem&lt;MoveSystem&gt;();
} <br>used to set the signatures, the components, that a <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> can use for in the entities
A signature is a set that contains ComponentType
<br>When setting the signature for the given <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>, any created entity that contain the same components, it doesn't matter if the entity has more components, that are set in a signature are made available to that <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> to access, if the entity doesn't contain the required components they are then removed from that <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>.
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Texture{ int ID;
}; // define system
class MoveSystem : public System{
...
}; void func(){ // initialize ECS // register system // create system signature Signature sig; // give the signature the components sig.set(ECS::GetComponentType&lt;Position&gt;()); sig.set(ECS::GetComponentType&lt;Texture&gt;()); // set system signature ECS::SetSystemSignature&lt;MoveSystem&gt;(sig); // system has access to entities with Position and Texture components...
} // alternative
void func(){ // initialize ECS // register system // set system signature ECS::SetSystemSignature&lt;MoveSystem&gt;( ECS::GetComponentType&lt;Position&gt;(), ECS::GetComponentType&lt;Texture&gt;() ); // system has access to entities with Position and Texture components...
}
]]></description><link>engine/ecs/src/system.html</link><guid isPermaLink="false">Engine/ECS/src/System.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[ECS]]></title><description><![CDATA[The Entity Component System is a different approach to representing objects or "GameObjects" and using them to keep track and allow for some functionality. Despite its performance benefits, though its design and usage requires a lot more thinking and even getting used to if you've been used to OOP. This general information should give enough information to start thinking about and not only that there will be examples and tutorials showing its usage and application.To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're includedFor example: including a Static Singleton Class like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;resourcesystems/managers/texture_manager.hpp&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as a static object with its private static variables. However, this means that the static functions can be called without having to keep manual storage of the static objectIn C++ to use a static function of a Static Singleton Class can be done as follow:#include &lt;resourcesystems/managers/texture_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL TextureManager::BindTextures();
}
ECS is comprised of three modules:
<br><a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a>
<br><a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>
<br><a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>
<br>Each of these modules work together, all to represent the <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a> which is the ID that represents your objects like Player, a UI element, or an Item.Header location/class name:#include &lt;ecs/ecs.hpp&gt; class ECS{
...
};
Helpful definitions:
'T' - refers to an arbitrary type
<br>used to initialized ECS to allow for usage for <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> and <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>
by default, the char option 'd' is set to allow for checking and printing errors
the char option 'r' is used to disable for printing and checking for some errors however you must appropriately check that no errors are encountered to fully make use of this option
calling this function again causes a warning
void func(){ // initialize ECS ECS::Init();
} used to create an entity, returns the value that refers to that create entity
there's a limit of how many entities can be created in total which is 10000
void func(){ // initialize ECS // create an entity Entity entity = ECS::CreateEntity(); // do something with created entity...
} used to get an existing entity's component signature
help for identifying all the components within given entity
void func(){ // initialize ECS // create an entity // add a component to entity // get signature from entity Signature sig = ECS::GetEntitySignature(entity);
} used to destroy a given entity
it also removes all components attached to that entity
avoid storing important data or pointers in components that are then onto the entity as it will be lost and may cause a segfault when trying to access the pointer that was on the entity
void func(){ // initialize ECS // create an entity // optional: add component to entity= // destroy entity ECS::DestroyEntity(entity);
} <br>used to register a specified <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> for <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a> and <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> usage
due note that without registering a component, you can't add such component to an entity or create signatures for systems
// define a component
// EX: test component called 'Position' contains a float variables
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component ECS::RegisterComponent&lt;Position&gt;(); // add component to an entity or create signature for system...
} <br>used to add a specified <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> to an existing entity
due note that the specified component must be registered beforehand in order for it work
When adding components to an entity, you can add multiple components at the same time and you can initialize the values of the components all within the same line of code
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Texture{ int ID;
}; void func(){ // initialize ECS // register component 'Position' // create entity // add component to entity ECS::AddComponent(entity, Position{});
} // *Alternative*
void func(){ // initialize ECS // register component 'Position' // create entity // add component to entity, and initalize values ECS::AddComponent(entity, Position{ .x = 10, .y = 20 });
} // *Alternative*
void func(){ // initialize ECS // register components // create entity // add multiple component to entity, and initalize values ECS::AddComponent(entity, Position{ .x = 10, .y = 20 }, Texture{ .ID = 3 });
} <br>used to remove a <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> from an existing entity
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // create entity // add component to entity // remove component from entity ECS::RemoveComponent&lt;Position&gt;(entity);
} <br>used to get reference of an existing entity's <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>
if the component is not registered then it will return an error
if the entity doesn't have such component then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // create entity // add component to entity // get entity component Position&amp; pos = ECS::GetComponent&lt;Position&gt;(entity); // modify the component pos.x += 10.0f; pos.y -= 5.0f;
} <br>used to check if the entity contains given <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // create entity // add component to entity // check if entity has component if(ECS::CheckComponent&lt;Position&gt;(entity) == true){ // entity does have component // do something... }
} <br>used to get the component type of given <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a> ComponentType is a uint8_t where each bit belongs to a registered component
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // get component type from registered component ComponentType type = ECS::GetComponentType&lt;Position&gt;();
} <br>used to retrieve the signature of given <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>
ComponentType is a uint8_t where each bit belongs to a registered component, which is then stored into a signature format
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; void func(){ // initialize ECS // register component // get signature from registered component Signature sig = ECS::GetComponentSignature&lt;Position&gt;();
} used to retrieve the signature of given component types
ComponentType is a uint8_t where each bit belongs to a registered component, which is then stored into a signature format
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Material{ float r, g, b;
}; void func(){ // initialize ECS // register components // get signature from registered components Signature sig = ECS::GetMultiComponentSignature( ECS::GetComponentType&lt;Position&gt;(), ECS::GetComponentType&lt;Material&gt;() );
} used to retrieve the bit location that the given component belongs to
if the component is not registered then it will return an error
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Material{ float r, g, b;
}; void func(){ // initialize ECS // register component // get signature from registered components unsigned int pos_sig_bit = ECS::GetComponentSignatureBit&lt;Position&gt;(); unsigned int mat_sig_bit = ECS::GetComponentSignatureBit&lt;Material&gt;(); // The value of pos_sig_bit is 1 in decimal or ...000000000001 in binary // The value of mat_sig_bit is 2 in decimal or ...000000000010 in binary
} <br>used to register a <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> and it as well returns the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> reference for external use
<br>returns nullptr if the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> is already registered
// define system
class MoveSystem : public System{
...
}; void func(){ // initialize ECS // register system ECS::RegisterSystem&lt;MoveSystem&gt;();
} // Alternative
void func(){ // initialize ECS // register system and get the system reference std::shared_ptr&lt;MoveSystem&gt; system = ECS::RegisterSystem&lt;MoveSystem&gt;();
} <br>used to get reference of a registered <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>
<br>returns nullptr if the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> hasn't been registered
// define system
class MoveSystem : public System{
...
}; void func(){ // initialize ECS // register system // get registered system std::shared_ptr&lt;MoveSystem&gt; system = ECS::GetSystem&lt;MoveSystem&gt;();
} <br>used to set the signatures, the components, that a <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> can use for in the entities
A signature is a set that contains ComponentType
<br>When setting the signature for the given <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>, any created entity that contain the same components, it doesn't matter if the entity has more components, that are set in a signature are made available to that <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> to access, if the entity doesn't contain the required components they are then removed from that <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>.
// define components
// EX: the following components are used as example
struct Position{ float x, y;
}; struct Texture{ int ID;
}; // define system
class MoveSystem : public System{
...
}; void func(){ // initialize ECS // register system // create system signature Signature sig; // give the signature the components sig.set(ECS::GetComponentType&lt;Position&gt;()); sig.set(ECS::GetComponentType&lt;Texture&gt;()); // set system signature ECS::SetSystemSignature&lt;MoveSystem&gt;(sig); // system has access to entities with Position and Texture components...
} // alternative
void func(){ // initialize ECS // register system // set system signature ECS::SetSystemSignature&lt;MoveSystem&gt;( ECS::GetComponentType&lt;Position&gt;(), ECS::GetComponentType&lt;Texture&gt;() ); // system has access to entities with Position and Texture components...
}
<br>Once finished reading all that make up the ECS system, you can then move onto learning how to use it all so refer to <a data-href="ECS Usage" href="engine/ecs/ecs-usage.html" class="internal-link" target="_self" rel="noopener nofollow">ECS Usage</a> to get a better understanding on how to use ECS]]></description><link>engine/ecs/ecs.html</link><guid isPermaLink="false">Engine/ECS/ECS.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[ECS Usage]]></title><description><![CDATA[This page will shows an example on how to use the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> module, please refer to <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> before continuing reading this usage example<br>That documentation for for each of the modules (i.e <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a>, <a data-href="Component" href="engine/ecs/src/component.html" class="internal-link" target="_self" rel="noopener nofollow">Component</a>, <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>) will refer to the header that contains all the modules in one:#include &lt;ecs/ecs.hpp&gt;
So this page will only explain how to use it, and each of the module pages will explain the details and all functions of ECS as well as further usageTo better explain usage of ECS is better with a step by step on how to use and both explain each modules, it will be done by example: so lets create a Player using ECS able to move around using input. Be sure to review the modules before starting this exampleFirst initialize ECS in order to use it:#include &lt;ecs/ecs.hpp&gt; void func(){ // initialize ECS for app usage ECS::Init();
}
Define components that will be attached to the Player:Since the Player will be moved around. We'll choose to move the player on a 2D space so the Player needs a component that contains the player's position:// this can be it own header which will be called "player_component.hpp" // representation of the Player's position
struct Position{ float x; // x-axis position float y; // y-axis position
};
Now we then register the component to allow for usability of it within ECS#include &lt;ecs/ecs.hpp&gt;
// include the define component defined above
#include "player_component.hpp" void func(){ // initialize ECS for app usage ECS::Init(); // register components ECS::RegisterComponent&lt;Position&gt;();
}
<br>For moving the Player, we need to define a <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> where the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> which will automatically handle grabbing the player, then the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> we defined can get the component that is attached to the Player, then update the player transform. We can also define alias that refers to the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a><br>So let's create such <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>. // header file named "move_system.hpp" // include system to create our own
#include &lt;ecs/types/system.hpp // inherit from System to classify this to the ECS that this is a system
// also gives access to "entities" list which are entities given by ECS that // meet the required signature
class MoveSystem : public System{ public: // Move function void Move();
}; // define alias
using MoveSystem_Ptr = std::shared_ptr&lt;MoveSystem&gt;; // source file
#include "move_system.hpp"
// ECS to allow for grabbing components of entities
#include &lt;ecs/ecs.hpp&gt;
// defined component defined above
#include "player_component.hpp" void MoveSystem::Move(){ // grab all entities with the set signature for(auto const&amp; entity : entities){ // grab reference of "Position" component from entity auto&amp; pos = ECS::GetComponent&lt;Position&gt;(entitiy); // move the position on x axis if(*insert input checking code here*){ pos.x += 1.0f; } }
}
<br>Then we need to register the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> we just created so we can then use the system and allow <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> to automatically give a list of entities that have the components the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> needs which is the "Position" component#include &lt;ecs/ecs.hpp&gt;
// include the component defined above
#include "player_component.hpp"
// include the system defined above
#include "move_system.hpp" void func(){ // initialize ECS for app usage // register components // register system and get reference of the system MoveSystem_Ptr moveSys = ECS::RegisterSystem&lt;MoveSystem&gt;();
}
<br>To let <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> give the entities that have the "Position" component to the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> we created we need to define a signature or a list of components that a <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a> needs to satisfy in order to be included into the <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>#include &lt;ecs/ecs.hpp&gt;
// include the component defined above
#include "player_component.hpp"
// include the system defined above
#include "move_system.hpp" void func(){ // initialize ECS for app usage // register components // register system and get reference of the system // create signature Signature sig; // give the signature the components sig.set(ECS::GetComponentType&lt;Position&gt;()); // set the system's signature ECS::SetSystemSignature&lt;MoveSystem&gt;(sig);
} // alternative
void func(){ // initialize ECS for app usage // register components // register system and get reference of the system // set the system's signature ECS::SetSystemSignature&lt;MoveSystem&gt;( ECS::GetComponentType&lt;Position&gt;() );
}
<br>Now we need a Player <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a> with the component "Position" and to the component set default values#include &lt;ecs/ecs.hpp&gt;
// include the component defined above
#include "player_component.hpp"
// include the system defined above
#include "move_system.hpp" void func(){ // initialize ECS for app usage // register components // register system and get reference of the system // set the system's signature // create entity Entity Player = ECS::CreateEntity(); // give component to entity ECS::AddComponent(Player, Position{.x = 0.0f, .y = 0.0f});
}
<br>Lastly, we need to call the function of <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a> called "MoveSystem" to update the Player <a data-href="Entity" href="engine/ecs/src/entity.html" class="internal-link" target="_self" rel="noopener nofollow">Entity</a> so it can move to the right#include &lt;ecs/ecs.hpp&gt;
// include the component defined above
#include "player_component.hpp"
// include the system defined above
#include "move_system.hpp" void func(){ // initialize ECS for app usage // register components // register system and get reference of the system // set the system's signature // create entity // give component to entity // update entities with system reference moveSys-&gt;Move();
}
<br>That should be pretty much it for the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> in using from scratch, look into <a data-href="Tutorial" href="tutorial/tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">Tutorial</a> on actual application of the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> to create a simple game using this engine.]]></description><link>engine/ecs/ecs-usage.html</link><guid isPermaLink="false">Engine/ECS/ECS Usage.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[line]]></title><description><![CDATA[<img src="engine/engine/src/images/line.png" target="_self">]]></description><link>engine/engine/src/images/line.html</link><guid isPermaLink="false">Engine/Engine/src/images/line.png</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate><enclosure url="engine/engine/src/images/line.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;engine/engine/src/images/line.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Line Renderer]]></title><description><![CDATA[The Line Renderer is responsible for rendering Lines given raw data. It provides multiples ways to render Lines or Rectangles either by rendering each individually or all at the same time. In order for this class to function it needs OpenGL to be initialized before utilizing this class.The types of things that the Line Renderer can render which are Lines are considered and can be called "render primitives" and below are examples of what they looks like:Line:
<img alt="line.png" src="engine/engine/src/images/line.png" target="_self">
Rectangle or Quad Wireframe:<br>
<img alt="quadwire.png" src="engine/engine/src/images/quadwire.png" target="_self">Refer to GLM documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://glm.g-truc.net/0.9.9/api/modules.html" target="_self">http://glm.g-truc.net/0.9.9/api/modules.html</a>
Refer to OpenGL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Refer to GLSL documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_self">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a>
To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included<br>For example: including a Static Singleton Class like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;ResourceSystems/Managers/ResourceManager.hpp&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as a static object with its private static variables. However, this means that the static functions can be called without having to keep manual storage of the static objectIn C++ to use a static function of a Static Singleton Class can be done as follow:#include &lt;resourcesystems/managers/resource_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL TextureManager::BindTextures();
}
<br>The Line Renderer does require a <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> to be loaded and contain the following layout variables for the vertex <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> and fragment <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> for each render primitive:Line:// Vertex
layout (location = 0) in vec2 vertex; layout (location = 1) in vec4 color; out vec4 o_lineColor; uniform mat4 projectionView; // Fragment
in vec4 o_lineColor; out vec4 color; <br>Before using the Line Renderer it needs to be initialized and given a <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> so the class contains a "Init()", in the example below we'll use <a data-href="Shader Manager" href="engine/resourcesystems/src/shader-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Shader Manager</a> to load a <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a>, use <a data-href="Camera" href="engine/cameras/camera.html" class="internal-link" target="_self" rel="noopener nofollow">Camera</a> to provide "projectionView" calculation and then initialize the Line Renderervoid func(){ // load the LINE shader using Shader Manager ShaderManager::LoadShader("line.vert", "line.frag", nullptr, "line"); // get the LINE shader Shader&amp; line = ShaderManager::GetShader("line"); // apply projection calculation to the Line Shader using Camera Camera cam; cam.setDimensions(1280, 720); cam.calculateProjectionView(line); // initialize Line Rendeder for Line rendering LineRenderer::Init(line);
}
<br>When it comes to rendering you MUST call certain function pertaining to both OpenGL and whichever <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> library you pick like SDL or GLFW or customvoid func(){ // clear screen glClear(GL_COLOR_BUFFER_BIT); // render something, example: using Line Renderer // example: swap window buffers using GLFW glfwSwapBuffers(windowHandle); }
<br>Fortunately, the already build window classes, <a data-href="Window-GLFW" href="engine/window/src/window-glfw.html" class="internal-link" target="_self" rel="noopener nofollow">Window-GLFW</a> and <a data-href="Window-SDL" href="engine/window/src/window-sdl.html" class="internal-link" target="_self" rel="noopener nofollow">Window-SDL</a>, can already do this for you and they provide a paradigm which you can find in <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> where to do all your renderingHeader location/class name:#include &lt;engine/line_renderer.hpp class LineRenderer{
...
}; used to initialize line rendering and set a shader
the width of lines by default is set to be 1, can be changed later however does also affects quad wireframe objects and all lines being rendered
also when initializing the line renderer it allows for rendering rectangles or otherwise known as quad wireframe objects
When calling this function again, it will give a warning that it has been already initialized
void func(){ // load LINE shader // calculate projection and apply to LINE shader // initialize Line Renderer for line rendering LineRenderer::InitLine(lineShader);
} draw a single line using two given points
the raw data consists of the following: start position
end position
color &lt;- all RGBA values set to 1 the width of lines by default is set to be 1, can be changed later however does also affects quad wireframe objects and all lines being rendered
due note that line rendering must be initialized otherwise you will be given an error message
// using window paradigm
void init(){ // load LINE shader // calculate projection and apply to LINE shader // initialize line rendering LineRenderer::InitLine(lineShader);
} ... void render(double alpha){ // render a line LineRenderer::DrawLine({0.0f, 0.0f}, {5.0f, 5.0f});
} draw a single wireframe of a quad utilizing lines
the data consists of the following: position
size
rotation
color &lt;- all RGBA values set to 1 the width of lines by default is set to be 1, can be changed later however does also affects quad wireframe objects and all lines being rendered
due note that line rendering must be initialized otherwise you will be given an error message
// using window paradigm
void init(){ // load LINE shader // calculate projection and apply to LINE shader // initialize line rendering LineRenderer::InitLine(lineShader);
} ... void render(double alpha){ // render a line LineRenderer::DrawQuadWireFrame(position, size, rotation);
} stack a single line using two given points
after calling this function it is REQUIRED to call FlushLines() in order to render what was stored
without the FlushLines() stacked objects will be rendered either way, however the behavior is undefined and could lead to issues or errors
the raw data consists of the following: start position
end position
color &lt;- all RGBA values set to 1 the width of lines by default is set to be 1, can be changed later however does also affects quad wireframe objects and all lines being rendered
due note that line rendering must be initialized otherwise you will be given an error message
it is faster to stack multiple lines than doing a singular draw for each line as it utilizes the batch rendering technique
// using window paradigm
void init(){ // load LINE shader // calculate projection and apply to LINE shader // initialize line rendering LineRenderer::InitLine(lineShader);
} ... void render(double alpha){ // render lines // stack multiple lines LineRenderer::StackLine({0.0f, 0.0f}, {5.0f, 5.0f}); LineRenderer::StackLine({2.0f, 2.0f}, {7.0f, 7.0f}); //render all lines stacked LineRenderer::FlushLines();
} used to tell to the GPU to render the stored lines in the buffer
this causes a single draw call request to the GPU
it is REQUIRED to call this function when stacking lines
// using window paradigm
void init(){ // load a texture // load LINE shader // calculate projection and apply to LINE shader // initialize line rendering LineRenderer::InitLine(lineShader);
} ... void render(double alpha){ // render lines // stack multiple lines ... // render all lines stacked LineRenderer::FlushLines();
} set the width of all lines being rendered
cannot be used to individually set the width of lines
doesn't require for line rendering to be initialized
void func(){ // set a line width for all lines LineRenderer::SetLineWidth(2.0f);
} get the current width of all lines
doesn't require for line rendering to be initialized
void func(){ // get the width of all lines float width = LineRenderer::GetLineWidth();
}
]]></description><link>engine/engine/src/line-renderer.html</link><guid isPermaLink="false">Engine/Engine/src/Line Renderer.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate><enclosure url="engine/engine/src/images/line.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;engine/engine/src/images/line.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Quad Renderer]]></title><description><![CDATA[The Quad Renderer is responsible for rendering Quads raw data. It provides multiples ways to render Quads either by rendering each individually or all at the same time. In order for this class to function it needs OpenGL to be initialized before utilizing this class.The types of things that the Quad Renderer can render which are Quads are considered and can be called "render primitives" and below are examples of what they looks like:Quad:
<img alt="quad.png" src="engine/engine/src/images/quad.png" target="_self">Refer to GLM documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="http://glm.g-truc.net/0.9.9/api/modules.html" target="_self">http://glm.g-truc.net/0.9.9/api/modules.html</a>
Refer to OpenGL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Refer to GLSL documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_self">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a>
To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included<br>For example: including a Static Singleton Class like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;resourcesystems/managers/texture_manager.hpp&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as a static object with its private static variables. However, this means that the static functions can be called without having to keep manual storage of the static objectIn C++ to use a static function of a Static Singleton Class can be done as follow:#include &lt;resourcesystems/managers/texture_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL TextureManager::BindTextures();
}
<br>The Quad Renderer does require a <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> to be loaded and contain the following layout variables for the vertex <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> and fragment <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> (if it needs it) for each render primitive:Quad:// Vertex
layout (location = 0) in vec2 vertex; layout (location = 1) in vec2 texCoords; layout (location = 2) in float texIndex;
layout (location = 3) in vec4 color; out vec2 o_TexCoords;
out float o_TexIndex;
out vec4 o_quadColor; uniform mat4 projectionView; // Fragment
in vec2 o_TexCoords;
in vec4 o_quadColor;
in float o_TexIndex; out vec4 color; uniform sampler2D image[32];
<br>Before using the Quad Renderer it needs to be initialized and given a shader so the class contains a "Init()", in the example below we'll use <a data-href="Shader Manager" href="engine/resourcesystems/src/shader-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Shader Manager</a> to load a shader, use <a data-href="Camera" href="engine/cameras/camera.html" class="internal-link" target="_self" rel="noopener nofollow">Camera</a> to provide "projectionView" calculation and then initialize the Quad Renderervoid func(){ // load the QUAD shader using Resource Manager ShaderManager::LoadShader("quad.vert", "quad.frag", nullptr, "quad"); // get the QUAD shader Shader&amp; quad = ShaderManager::GetShader("quad"); // apply projection calculation to the Quad Shader using Camera Camera cam; cam.setDimensions(1280, 720); cam.calculateProjectionView(quad); // initialize Quad Rendeder for Quad rendering QuadRenderer::InitQuad(quad;
}
Within the Quad Renderer it is flexible on which render primitive you want to use or want to enable later in your application<br>When it comes to rendering you MUST call certain function pertaining to both OpenGL and whichever <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> library you pick like SDL or GLFW or customvoid func(){ // clear screen glClear(GL_COLOR_BUFFER_BIT); // render something, example: using Quad Renderer // example: swap window buffers using GLFW glfwSwapBuffers(windowHandle); }
<br>Fortunately, the already build window classes, <a data-href="Window-GLFW" href="engine/window/src/window-glfw.html" class="internal-link" target="_self" rel="noopener nofollow">Window-GLFW</a> and <a data-href="Window-SDL" href="engine/window/src/window-sdl.html" class="internal-link" target="_self" rel="noopener nofollow">Window-SDL</a>, can already do this for you and they provide a paradigm which you can find in <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> where to do all your renderingBecause of the fragments variable that the Quad Renderer interacts with // Fragment
uniform sampler2D image[32];
It requires textures that are loaded to be bounded to an index from 0-31. The variable mentioned in the fragment shader must be initializedvoid func(){ // grab the uniform location of 'image' in the shader, the name 'image' is explicit auto loc = glGetUniformLocation(quadShader.getID(), "image"); // set up array to the size of the max number of textures int samplers[maxTextureSlots]; // set up samplers array for (int i = 0; i &lt; maxTextureSlots; i++){ samplers[i] = i; }
}
To bind each loaded texture to an index from 0-31, due note that the engine by default uses OpenGL 4.5 so here how it's donevoid func(){ // texIDList contains a list of unique ID from loaded textures // bind all the textures from first to last for(int i = 0; i &lt; texIDList.size(); i++){ // call to bind texture by their ID to an index glBindTextureUnit(i, texIDList[i]); }
}
Using a texture depending on how you organized your textures you should utilize the index and not the texture ID to apply a texture to whatever you are rendering.<br>However, all of this texture binding is already done through <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> so the explanation given above is only useful when making your own solutionHeader location/class name:#include &lt;engine/quad_renderer.hpp class QuadRenderer{
...
}; used to initialize quad rendering and set the shader
When calling this function again, it will give a warning that it has been already initialized
void func(){ // load QUAD shader // calculate projection and apply to QUAD shader // initialize Quad Renderer for quad rendering QuadRenderer::InitQuad(quadShader);
} draw a singular quad utilizing given raw data
the raw data consists of the following: <br>texture index &lt;- found through <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
position
size
rotation
color &lt;- all RGBA values set to 1
texture coordinates &lt;- Optional
vertex coordinates &lt;- Optional due note that quad rendering must be initialized otherwise you will be given an error message
// using window paradigm
void init(){ // load a texture // load QUAD shader // calculate projection and apply to QUAD shader // initialize quad rendering Quadenderer::InitQuad(quadShader);
} ... void render(double alpha){ // render a quad int texIndex = TextureManager::GetTextureIndex("example") QuadRenderer::DrawQuad(texIndex, pos, size, rotation);
} store a single quad utilizing given raw data
after calling this function it is REQUIRED to call FlushQuad() in order to render what was stored
without the FlushQuad() stacked objects will be rendered either way, however the behavior is undefined and could lead to issues or errors
the raw data consists of the following: <br>texture index &lt;- found through <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
position
size
rotation
color &lt;- all RGBA values set to 1
texture coordinates &lt;- Optional
vertex coordinates &lt;- Optional due note that quad rendering must be initialized otherwise you will be given an error message
it is faster to stack multiple quads than doing a singular draw for each quad as it utilizes the batch rendering technique
// using window paradigm
void init(){ // load a texture // load QUAD shader // calculate projection and apply to QUAD shader // initialize quad rendering QuadRenderer::InitQuad(quadShader);
} ... void render(double alpha){ // render a quad // get texture index from a loaded texture int texIndex = TextureManager::GetTextureIndex("example") // stack multiple quads QuadRenderer::StackQuad(texIndex, position, size, rotation); QuadRenderer::StackQuad(texIndex, position, size, rotation); // render all quads stacked QuadRenderer::FlushQuads();
} used to tell to the GPU to render the stored quads in the buffer
this causes a single draw call request to the GPU
it is REQUIRED to call this function when stacking quads
// using window paradigm
void init(){ // load a texture // load QUAD shader // calculate projection and apply to QUAD shader // initialize quad rendering QuadRenderer::InitQuad(quadShader);
} ... void render(double alpha){ // render quads // stack multiple quads ... // render all quads stacked QuadRenderer::FlushQuads();
}
]]></description><link>engine/engine/src/quad-renderer.html</link><guid isPermaLink="false">Engine/Engine/src/Quad Renderer.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate><enclosure url="engine/engine/src/images/quad.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;engine/engine/src/images/quad.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Text Renderer]]></title><description><![CDATA[The Text Renderer is responsible for rendering text given a font and raw data. It provides for flexible output of different fonts. In order for this class to function it needs OpenGL to be initialized before utilizing this class.Refer to GLM documentation: <a rel="noopener nofollow" class="external-link is-unresolved" href="http://glm.g-truc.net/0.9.9/api/modules.html" target="_self">http://glm.g-truc.net/0.9.9/api/modules.html</a>
Refer to OpenGL documentation: <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.opengl.org/Documentation/Documentation.html" target="_self">https://www.opengl.org/Documentation/Documentation.html</a> <br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Main_Page" target="_self">https://www.khronos.org/opengl/wiki/Main_Page</a>
Refer to GLSL documentation:
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)" target="_self">https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)</a>
To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included<br>For example: including a Static Singleton Class like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;resourcesystems/managers/texture_manager.hpp&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as a static object with its private static variables. However, this means that the static functions can be called without having to keep manual storage of the static objectIn C++ to use a static function of a Static Singleton Class can be done as follow:#include &lt;resourcesystems/managers/texture_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL TextureManager::BindTextures();
}
<br>The Text Renderer does require a shader to be loaded and contain the following layout variables for the vertex <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> and fragment <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> for rendering text:Text:// Vertex
layout (location = 0) in vec3 vertex; layout (location = 1) in vec2 texCoords; layout (location = 2) in vec4 color; out vec2 o_TexCoords;
out vec4 o_color; uniform mat4 projectionView; // Fragment
in vec2 o_TexCoords;
in vec4 o_color; out vec4 color; layout (binding = 0) uniform sampler2D text;
<br>Before using the Text Renderer it needs to be initialized and given a shader so the class contains a "Init()", in the example below we'll use <a data-href="Shader Manager" href="engine/resourcesystems/src/shader-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Shader Manager</a> to load a shader and <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> to load the font, use <a data-href="Camera" href="engine/cameras/camera.html" class="internal-link" target="_self" rel="noopener nofollow">Camera</a> to provide "projectionView" calculation and then initialize the Text Renderervoid func(){ // load the TEXT shader using Shader Manager ShaderManager::LoadShader("text.vert", "text.frag", nullptr, "text"); // load a font using the Texture Manager TextureManager::LoadFontTexture("fonts/Arial.tff", "font", 512, 512, 64.0f); // get the TEXT shader Shader&amp; text = ShaderManager::GetShader("text"); // apply projection calculation to the Line Shader using Camera Camera cam; cam.setDimensions(1280, 720); cam.calculateProjectionView(text); // initialize Text Rendeder for Text rendering TextRenderer::Init(text, current_window_height);
}
<br>When it comes to rendering you MUST call certain function pertaining to both OpenGL and whichever <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> library you pick like SDL or GLFW or customvoid func(){ // clear screen glClear(GL_COLOR_BUFFER_BIT); // render something, example: using Text Renderer // example: swap window buffers using GLFW glfwSwapBuffers(windowHandle); }
<br>Fortunately, the already build window classes, <a data-href="Window-GLFW" href="engine/window/src/window-glfw.html" class="internal-link" target="_self" rel="noopener nofollow">Window-GLFW</a> and <a data-href="Window-SDL" href="engine/window/src/window-sdl.html" class="internal-link" target="_self" rel="noopener nofollow">Window-SDL</a>, can already do this for you and they provide a paradigm which you can find in <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> where to do all your renderingHeader location/class name:#include &lt;engine/text_renderer.hpp&gt; class TextRenderer{
...
}; used to initialize text rendering of all text
requires the height of the display area which is used to calculate the pixel scale of the rendered text
When calling this function again, it will give a warning that it has been already initialized
void func(){ // load TEXT shader // load a font texture // calculate projection and apply to TEXT shader // initialize Text Renderer for text rendering TextRenderer::Init(textShader, currrent_window_height);
} used to draw text on the screen using a loaded font
the raw data consists of the following: <br>CharacterSet &lt;- found through <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
position
rotation
size
color &lt;- all RGBA values set to 1 by default <br>recommended to use a font loaded through from the <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
// using window paradigm
void init(){ // load TEXT shader // calculate projection and apply to TEXT shader // load font // initialize Text Renderer for text rendering TextRenderer::Init(textShader, window_height);
} ... void render(double alpha){ // get loaded font auto&amp; font = TextureManager::GetFontTexture("arial"); // render text TextRenderer::DrawCharacters(font, "example text", {0.5f, 0.0f, 0.0f}, 45.0f, 1.0f);
} used to store text on the stack,can be called multiple times, which can be then be "Flushed" or renderer on the screen using a loaded font
after calling this function it is REQUIRED to call FlushText() in order to render what was stored. Without the FlushText() stacked objects will be rendered either way, however the behavior is undefined and could lead to issues or errors
NOTE: if wanting to use multiple fonts you need to stack and flush for each particular font being used, it's not possible to mix different fonts when stacking
the raw data consists of the following: <br>CharacterSet &lt;- found through <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
position
rotation
size
color &lt;- all RGBA values set to 1 by default <br>recommended to use a font loaded through from the <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
due note that text rendering must be initialized otherwise you will be given an error message
it is faster to stack multiple text than doing a singular draw for each text as it utilizes the batch rendering technique which allows to render all at once
// using window paradigm
void init(){ // load TEXT shader // calculate projection and apply to TEXT shader // load font // initialize Text Renderer for text rendering TextRenderer::Init(textShader, window_height);
} ... void render(double alpha){ // get loaded font auto&amp; font = TextureManager::GetFontTexture("arial"); // stack text TextRenderer::StackCharacters(font, "example text", {0.5f, 0.0f, 0.0f}, 45.0f, {1.0f, 1.0f}); TextRenderer::StackCharacters(font, "Hello World!", {-0.5f, 0.0f, 0.0f}, 0.0f, 0.8f); // draw text TextRenderer::FlushText();
} set the window height, which is used to calculate the pixel scale of the rendered text
void func(){ // set the window height TextRenderer::SetWindowHeight(720);
} used to tell the GPU to render the stored text in the stack buffer
this causes a single draw call request to the GPU
<br>After the call of said function it calls BindTextures() from <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
it is REQUIRED to call this function when stacking text
// using window paradigm
void init(){ // load TEXT shader // calculate projection and apply to TEXT shader // load font // initialize Text Renderer for text rendering TextRenderer::Init(textShader, window_height);
} ... void render(double alpha){ // get loaded font auto&amp; font = TextureManager::GetFontTexture("arial"); // stack text TextRenderer::StackCharacters(font, "example text", {0.5f, 0.0f, 0.0f}, 45.0f, {1.0f, 1.0f}); TextRenderer::StackCharacters(font, "Hello World!", {-0.5f, 0.0f, 0.0f}, 0.0f, 0.8f); // draw text TextRenderer::FlushText();
}
]]></description><link>engine/engine/src/text-renderer.html</link><guid isPermaLink="false">Engine/Engine/src/Text Renderer.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[Engine]]></title><description><![CDATA[The Engine modules are responsible for handling the heavy lifting such as Physics and Rendering, and others. Also, note that some modules don't work properly without a generated window handle context like the Renderer Modules.These Engine modules are all Static Singleton Classes where their resources are stored statically and automatically freed without any explicit function call. To include a Static Singleton module in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included.For example: including a Static Singleton module like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;resourcesystems/managers/resource_manager&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as static object with its private static variables.In C++ to use a function of a Static Singleton class can be done as follow:#include &lt;resourcesystems/managers/resource_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL // StaticClassName::Function() ResourceManager::BindTextures();
}
However, some of the Static Singleton Classes require more information to be fully used anywhere else so some may need to be used in sequence.<br>For example: <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a> requires a loaded <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> and optionally a set universal sprite size for any rendered quad sprite (also indirectly the <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a>'s projectionView must be set utilizing the <a data-href="Camera" href="engine/cameras/camera.html" class="internal-link" target="_self" rel="noopener nofollow">Camera</a> module)#include &lt;engine/sprite_renderer.hpp&gt; void func(){ //... load a shader //... set up camera and projection view // initialize sprite renderer with a shader and a custom 2D sprite size SpriteRenderer::Init(shader, {15.0f, 60.0f});
}
<br>Then the <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a> is now able to render (Also note that to render you must use the <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> function paradigm if you are utilizing the engine's <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> module)#include &lt;engine/sprite_renderer.hpp&gt; //* utilizing the Window paradigm void init(){ // load a shader // load a texture // set up camera and projection view // initialie sprite renderer with a shader and utilize default 2D sprite size
} //... void render(double alpha){ // render a quad on the screen SpriteRenderer::DrawQuad(textureIndex, position, size, rotation, color); } Here are all the Engine modules that handle a specific functionality:<br>
<a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a> - for handling quad, line, rectangle rendering<br>
<a data-href="Text Renderer" href="engine/engine/src/text-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Text Renderer</a> - for handling text renderingHere are all the Engine components/types:<br>
<a data-href="Interpolation" href=".html" class="internal-link" target="_self" rel="noopener nofollow">Interpolation</a>]]></description><link>engine/engine/engine.html</link><guid isPermaLink="false">Engine/Engine/Engine.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[3 Sisters-Framework-Engine]]></title><description><![CDATA[To understand the engine let's understand how what it contains and how it operates:this is the include header file tree:inc/ cameras/ ecs/ types/ managers/ prebuilt_components/ &lt;- Pre-defined ECS components engine/ components/ glad/ &lt;- Cross-platform OpenGL API input/ managers/ resourceSystems/ managers/ sound/ managers/ stb/ &lt;- Image, True Type, and Image Write STB window/
Resource/Functional modules of the engine are Static Singletons Classes where their resources are stored statically and automatically freed without any explicit function call.To include a Static Singleton Class in a source or header file can be done simply by including their header. Doing multiple includes makes no difference as long as they're included.For example: including a Static Singleton Class like <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>#include &lt;resourcesystems/managers/texture_manager.hpp&gt;
<br>From this point the class <a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a> calls its private constructor which only initializes as a static object with its private static variables.In C++ to use a function of a Static Singleton Class can be done as follow:#include &lt;resourcesystems/managers/texture_manager.hpp&gt; void func(){ // rebind all textures to be used by OpenGL TextureManager::BindTextures();
}
However, some of the Static Singleton Classes require more information to be fully used anywhere else so some may need to be used in sequence.<br>For example: <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a> requires a loaded <a data-href="Shader" href="engine/resourcesystems/src/shader.html" class="internal-link" target="_self" rel="noopener nofollow">Shader</a> #include &lt;engine/quad_renderer.hpp&gt; void func(){ // load a shader // apply projection calculation to the shader // initialize Quad renderer with a shader QuadRenderer::Init(shader);
}
Throughout the Documentation of this engine, each the module that are Static Singleton Classes are labelled.For quick reference, here are the Static Singleton Classes in the engine:
<br><a data-href="Texture Manager" href="engine/resourcesystems/src/texture-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Texture Manager</a>
<br><a data-href="Shader Manager" href="engine/resourcesystems/src/shader-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Shader Manager</a>
<br><a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a>
<br><a data-href="Line Renderer" href="engine/engine/src/line-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Line Renderer</a>
<br><a data-href="Text Renderer" href="engine/engine/src/text-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Text Renderer</a>
<br><a data-href="Sound Manager" href="engine/sound/src/sound-manager.html" class="internal-link" target="_self" rel="noopener nofollow">Sound Manager</a>
<br><a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a>
<br><a data-href="GLFW Gamepad" href="engine/input/src/glfw-gamepad.html" class="internal-link" target="_self" rel="noopener nofollow">GLFW Gamepad</a>
<br><a data-href="GLFW keyboard" href="engine/input/src/glfw-keyboard.html" class="internal-link" target="_self" rel="noopener nofollow">GLFW keyboard</a>
<br><a data-href="SDL Gamepad" href="engine/input/src/sdl-gamepad.html" class="internal-link" target="_self" rel="noopener nofollow">SDL Gamepad</a>
<br><a data-href="SDL keyboard" href="engine/input/src/sdl-keyboard.html" class="internal-link" target="_self" rel="noopener nofollow">SDL keyboard</a>
<br>The Entity Component System (<a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a>) is a different approach to representing objects or "GameObjects" and using them to keep track and allow for some functionality. Despite its performance benefits, though its design and usage requires a lot more thinking and even getting used to if you've been used to OOP. This general information should give enough information to start thinking about and not only that there will be examples and tutorials showing its usage and application.<br><a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> is a Static Singleton Class meaning it needs to be initialized before use#include &lt;ecs/ecs.hpp&gt; void func(){ // initialize ECS ECS::Init();
}
An Entity is represented as an ID, a number like 2 or 19, that is "linked" to an array of components like a position or texture component. This can be used to logically represent a Player, a UI element, or an Item.Entity is of type unsigned integer of 32-bit, the name "Entity" is an alias that points to that type. Thus declaring an Entity is the same as declaring said mentioned type.// with alias
Entity e;
// without the alias
std::uint32_t u; // both 'e' and 'u' are the same type
In ECS system handles giving an entity an ID, attaching components, and allow those entities with certain components (called a signature) that are used by systems.To create an Entity in code it would look like so#include &lt;ecs/ecs.hpp&gt; void func(){ // initialize ECS // create an entity ECS::CreateEntity();
}
Since the "CreateEntity()" returns an entity which can be used to keep track of that entity#include &lt;ecs/ecs.hpp&gt; void func(){ // create an entity Entity entity = ECS::CreateEntity(); // do something with 'entity' // ...
}
A Component is represented as a data structure that only contains data. So to create a component it would look likes this:// example component with data
struct Component{ int value; float timer;
};
These components can be attached to an entity or numerous entities. Each entity can have the same component but they'll have a different instance of that same component, meaning similar components attached to different entities don't affect each other when a change only happens to one component or entity.<br>In the <a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a> the component that going to be used must be registered in order for the components to be used and <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>s to work properly, can be done so by using "RegisterComponent&lt;&gt;()"#include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; void func(){ // initialize ECS // register component ECS::RegisterComponent&lt;ComponentExample&gt;();
}
To attach a component to a entity using "AddComponent()"#include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; void func(){ // initialize ECS // register components // create an entity Entity entity = ECS::CreateEntity(); // attach component to entity ECS::AddComponent(entity, ComponentExample{});
}
It is also possible to set values of a component right when adding the component to the entity#include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; void func(){ // initialize ECS // register components // create an entity Entity entity = ECS::CreateEntity(); // attach component to entity ECS::AddComponent(entity, ComponentExample{.value = 10, .size = 2.0f});
}
<br>When adding a component to an entity it's added to an array in the "ComponentArray" which is just a list of components a entity is attached to and as more components are added it'll continue to fill each of these spots. This is useful for <a data-href="System" href="engine/ecs/src/system.html" class="internal-link" target="_self" rel="noopener nofollow">System</a>s because entities with certain components can be accessed by systems and entities with either one missing component or none at all aren't accessed as they are missing the base requirements.Due note that entities have a maximum amount of components they can have as well duplicate of the same components added or removed to an entity causes an error message but no compilation or runtime error occurs. To remove a component using "RemoveComponent()"#include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; void func(){ // initialize ECS // register components // create an entity Entity entity = ECS::CreateEntity(); // attach component to entity ECS::AddComponent(entity, ComponentExample{}); // remove component from entity ECS::RemoveComponent&lt;ComponentExample&gt;(entity);
}
There the obvious note that removing the component of an entity, the values set to that component of the entity is disposed of and lost. In similar fashion the "ComponentArray" attached to the entity also changes, meaning Systems with requiring a specific set of components and the entity now has one missing required component, the system will dispose access to that entity.To access component of an entity there are many ways to grab and change things of the component, here's a few examples of that using "GetComponent()"#include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; void func(){ // initialize ECS // register components // create an entity // attach ComponentExample to entity // take reference of the component in Entity ComponentExample&amp; component = ECS::GetComponent&lt;ComponentExample&gt;(entity); // modify component of the entity component.value += 30;
} #include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; void func(){ // initialize ECS // register components // create an entity // attach ComponentExample to entity // get component from entity and modify directly an attribute ECS::GetComponent&lt;ComponentExample&gt;(entity).size -= 1.0f;
} A System is sort of a manager that is able to access all entities that have a set of specific components that is required by the system in order to manipulate the entities.Systems require to be registered before usage utilizing "RegisterSystem()", this time it is required to keep a reference to the return of the function in order to use the functions provided by the system being used#include &lt;ecs/ecs.hpp&gt; void func(){ // initialize ECS // register system ExampleSystem system = ECS::RegisterSystem&lt;ExampleSystem&gt;();
}
When entities are given a component it'll not only attach the component to the entity but also fill a spot in its "ComponentArray" which is used to be compared to the System's "Signature". Signatures is a list of required components needed for an entity to be access by a System. There are two ways to set up the signatures of a system all using the same function "SetSystemSignature()":Creating a signature and adding it to the system#include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; // example component with data
struct TestComponent{ double length;
}; void func() { // initialize ECS // register components // register system // create signature Signature sig; // give the signature the components sig.set(ECS::GetComponentType&lt;ComponentExample&gt;()); sig.set(ECS::GetComponentType&lt;TestComponent&gt;()); // set the system's signatures ECS::SetSystemSignature&lt;ExampleSystem&gt;(sig); // use system example.doSomething();
}
Setting the signature directly onto function#include &lt;ecs/ecs.hpp&gt; // example component with data
struct ComponentExample{ int value; float size;
}; // example component with data
struct TestComponent{ double length;
}; void func() { // initialize ECS // register components // register system // set the system's signatures ECS::SetSystemSignature&lt;ExampleSystem&gt;( ECS::GetComponentType&lt;ComponentExample&gt;(), ECS::GetComponentType&lt;TestComponent&gt;()); // use system example.doSomething();
}
The following example modules are the classes that either optional or need to be inherited and its functions overwritten to allow for some or further functionality.<br>The Window class is responsible for creating a OpenGL context window which allows for direct/indirect functionality of other components within the engine such as the <a data-href="Quad Renderer" href="engine/engine/src/quad-renderer.html" class="internal-link" target="_self" rel="noopener nofollow">Quad Renderer</a>. Not only does this class provide a OpenGL context window it also provides a runtime function that keeps the context window open, provide runtime functions like the "update()" and "Render()"Furthermore, this class is intended and meant to be inherited because the functionality it provides needs to be arbitrarily defined, however there are some functions that can be optionally overridden to change their functionality to fulfill some purpose or need. <br>For example, when defining a what happens every frame we need to override "Update()" that is in the <a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a> class and give it a definitionvoid ExampleWindow::Update(){ // update logical systems every frame
}
The following classes that NEED to be overridden:
Init()
Update()
StepUpdate()
Input()
Render()
The Camera class allows for keeping track and provide calculation of projection and within this class it is optional to override the how the projection is calculated which is called "calculateProjectionView()"Within the Engine there is support for two different libraries that are for windowing and input which are:
GLFW
SDL
To allow for almost seamless transition between switching these libraries engine has its own unique namespace that pertains to them
For example, defining a window class utilizing GLFW windowing// take note of the included header
#include &lt;window/glfw_window.hpp&gt; // use the GLFW namespace
using namespace GLFW; class AppWindow : public Window{ // define the class...
};
Now, for a reasonable reason you would like to switch to SDL, here how its done for this peculiar example// take note of the included header
#include &lt;window/sdl_window.hpp&gt; // use the SDL namespace
using namespace SDL; class AppWindow : public Window{ // define the class...
}; However, you do need to look out for any differences between the two when it comes down to migrating from one to another as there can be some differences in missing feature or a function requires additional initializing variables or parameters. <br>Upon reaching at this point, you should understand what the engine contains and get an idea on how its ecosystem works. Now you can move onto understanding how each module operates, the list below will be listed in order of importance before heading into <a data-href="Usage" href="usage/usage.html" class="internal-link" target="_self" rel="noopener nofollow">Usage</a> which there we learn how to set up and make a simple game utilizing most the modules of the engine: <br><a data-href="Window" href="engine/window/window.html" class="internal-link" target="_self" rel="noopener nofollow">Window</a>
<br><a data-href="Resource Systems" href="engine/resourcesystems/resource-systems.html" class="internal-link" target="_self" rel="noopener nofollow">Resource Systems</a>
<br><a data-href="ECS" href="engine/ecs/ecs.html" class="internal-link" target="_self" rel="noopener nofollow">ECS</a>
<br><a data-href="Camera" href="engine/cameras/camera.html" class="internal-link" target="_self" rel="noopener nofollow">Camera</a>
<br><a data-href="Engine" href="engine/engine/engine.html" class="internal-link" target="_self" rel="noopener nofollow">Engine</a>
<br><a data-href="Input" href="engine/input/input.html" class="internal-link" target="_self" rel="noopener nofollow">Input</a>
<br><a data-href="Sound" href="engine/sound/sound.html" class="internal-link" target="_self" rel="noopener nofollow">Sound</a>
]]></description><link>engine/3-sisters-framework-engine.html</link><guid isPermaLink="false">Engine/3 Sisters-Framework-Engine.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate></item><item><title><![CDATA[3Sisters_Engine_logo]]></title><description><![CDATA[<img src="3sisters_engine_logo.png" target="_self">]]></description><link>3sisters_engine_logo.html</link><guid isPermaLink="false">3Sisters_Engine_logo.png</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate><enclosure url="3sisters_engine_logo.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;3sisters_engine_logo.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3Sisters]]></title><description><![CDATA[<img alt="3Sisters_Engine_logo.png" src="3sisters_engine_logo.png" target="_self">
Introduction:
A graphics framework-engine library written in C/C++ that currently has 2D graphics capabilities. The engine uses the OpenGL API for rendering graphics and other graphics to load assets, create entity, allow controller inputs, and etc. The engine is composed of the following libraries:DUE NOTE: This is a Legacy version of the engine and some or if not most of what is discussed here is relevant information of newer version Libraries:
GLFW &amp; SDL - For displaying a context window which allows OpenGL to render graphics.
GLAD - Cross-platform OpenGL API OpenAL - For playing sounds or music files
SndFile - For loading images
Why:
I've used the Unity Engine since 7th grade. I've used the engine on small projects and then on competitive club projects that have won trophies. I have struggled and grown tired with the software which made it very unpleasant to work with when working on solo projects or getting things done. I've seen a growing number of custom engines made by small developers and observed their workflow. After experimenting in creating this custom framework-engine I've enjoyed and learned a lot from working on it and creating small demos when using it.The main reason someone else would use this is to use it as a learning example as the engine is sort of representative of how engine's "from scratch" would be constructed. If considered to be used creating an application, due note there will be things you'll have to make yourself as the engine only covers boilerplate stuff such as Window, Renderer, and other.What to know before starting:<br>
Before starting I highly recommend to learn about OpenGL, plenty of C and C++, and understand the basics of graphics as well on your own make a very small and simple game, and if you don't know where to start I started with <a rel="noopener nofollow" class="external-link is-unresolved" href="https://learnopengl.com/" target="_self">https://learnopengl.com/</a> Getting to know the engine:<br>
<a data-href="3 Sisters-Framework-Engine" href="engine/3-sisters-framework-engine.html" class="internal-link" target="_self" rel="noopener nofollow">3 Sisters-Framework-Engine</a>Getting started with engine:<br>
<a data-href="Usage" href="usage/usage.html" class="internal-link" target="_self" rel="noopener nofollow">Usage</a><br>Creating with the <a data-href="3 Sisters-Framework-Engine" href="engine/3-sisters-framework-engine.html" class="internal-link" target="_self" rel="noopener nofollow">3 Sisters-Framework-Engine</a>:<br>
<a data-href="Tutorial" href="tutorial/tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">Tutorial</a>]]></description><link>3sisters.html</link><guid isPermaLink="false">3Sisters.md</guid><pubDate>Mon, 16 Feb 2026 23:36:47 GMT</pubDate><enclosure url="3sisters_engine_logo.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;3sisters_engine_logo.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>